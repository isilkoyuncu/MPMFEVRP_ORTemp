using MPMFEVRP.Domains.AlgorithmDomain;
using MPMFEVRP.Domains.SolutionDomain;
using MPMFEVRP.Implementations.Algorithms.Interfaces_and_Bases;
using MPMFEVRP.Implementations.ProblemModels.Interfaces_and_Bases;
using MPMFEVRP.Implementations.Solutions;
using MPMFEVRP.Models;
using MPMFEVRP.Models.XCPlex;
using MPMFEVRP.SupplementaryInterfaces.Listeners;
using System;
using System.Collections.Generic;
using MPMFEVRP.Domains.ProblemDomain;
using System.Linq;
using MPMFEVRP.Utils;
using System.IO;
using System.Diagnostics;


namespace MPMFEVRP.Implementations.Algorithms
{
    public class CGA_ExploitingGDVs_ProfitMax : AlgorithmBase
    {
        //Iteration stats
        int iterationNum = 0; //iteration number

        int numberOfColumnsExplored = 0; //columns added to the explored set
        int numberOfNegRedCostColumnsAdded = 0; //negative reduced cost columns added to the master set
        int numberOfPromisingCustomers = 0; //Customers having >0 shadow prices

        int numOfColumnsToSetPartitioning = 0;
        int totalNumOfColumnsExploredSoFar = 0;

        double relaxedSetPartitionTime = 0.0; //relaxed set partitioning duration
        double customerSetGeneratorTotalTime = 0.0;
        double customerSetGeneratorLocalTime = 0.0;
        double routeOptimizationTotalTime = 0.0; //total duration of the route optimization
        double routeOptimizationLocallTime = 0.0;
        double iterationTotalTimeCalculated { get { return (relaxedSetPartitionTime + customerSetGeneratorTotalTime + routeOptimizationTotalTime); } } //total duration of the iteration = relaxed set partitioning duration + total duration of the route optimization
        double iterationTotalTimeActual = 0.0;
        double cumulativeTotalTime = 0.0;

        double relaxedSetPartitionObjValue = 0.0; //objective function value of the relaxed set partitioning model
        double avgNumberOfCustomersExplored = 0.0;

        double iter = 0.0;
        double totalCustomers = 0.0;

        Stopwatch sw = new Stopwatch();
        Stopwatch swActual = new Stopwatch();

        List<CGIterationStats> cgIterationStatList;

        bool writeAllIncumbentSolns = true;

        //Datatable for estimated reduced costs Dictionary<customerID,Dictionary<
        Dictionary<string, Dictionary<CustomerSet, double>> estimatedLBofAddingCustomer2CSList;
        List<string> customerIDs;
        double evFixedCost;
        double gdvFixedCost;
        double evVariableCost;
        double gdvVariableCost;


        //Algorithm parameters
        double epsilon = 0.01;
        int minColumnsNeededPerIteration = 0;
        int maxColumnsAddedPerIteration;
        int columnsNeededPerCustomer = 1;
        bool preserveCustomerVisitSequence = false;
        bool addInitialCols = false;
        bool shake = false;
        int randomSeed;
        private Random random;
        Selection_Criteria selectedCriterion;
        TSPSolverType tspSolverType;
        double runTimeLimitInSeconds = 0.0;
        int numCustomers;
        bool feasibleIsEnough;
        bool performSwap;
        Exploiting_GDVs_Flowchart flowchart;

        XCPlexBase setPartitionSolver = null;
        XCPlex_SetCovering_wCustomerSets relaxedSetPartitionSolver;
        Dictionary<string, double> customerShadowPrices;
        Dictionary<string, double> vehicleShadowPrices;

        XCPlexParameters XcplexParam;

        CustomerSetList columns2setCover;
        CustomerSetList exploredCustomerSetMasterList;
        List<string> exploredCustomerSetMasterListIDs;


        CustomerSetBasedSolution solution = new CustomerSetBasedSolution();
        List<CustomerSetBasedSolution> allSolutions;
        CustomerSetBasedSolution incumbentSolution = new CustomerSetBasedSolution();
        List<double> incumbentTime;
        List<int> iterationNo;
        string[] writtenOutput;
        string[] writtenStatistics;
        double BKS;
        string instanceName = "";

        //Local statistics
        double totalRunTimeSec = 0.0;
        DateTime globalStartTime;
        DateTime globalFinishTime;
        //DateTime localFinishTime;
        List<OptimizationStatistics> optStatistics;

        bool terminate;
        string folder { get; set; }
        public CGA_ExploitingGDVs_ProfitMax()
        {
            AddSpecializedParameters();
        }
        public CGA_ExploitingGDVs_ProfitMax(double tilim, int randSeed, string f = null)
        {
            AddSpecializedParameters();
            algorithmParameters.UpdateParameter(ParameterID.ALG_RUNTIME_SECONDS, tilim);
            algorithmParameters.UpdateParameter(ParameterID.ALG_RANDOM_SEED, randSeed);
            folder = f;
        }
        public override void AddSpecializedParameters()
        {
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_FLOWCHART, "Flow Chart", new List<object>() { Exploiting_GDVs_Flowchart.a_NoExploiting, Exploiting_GDVs_Flowchart.b_OnlyIdenticalRoutes, Exploiting_GDVs_Flowchart.c_PathInsertedRoutes, Exploiting_GDVs_Flowchart.d_PathInsertedAndSwappedRoutes, Exploiting_GDVs_Flowchart.e_DataCollection }, Exploiting_GDVs_Flowchart.c_PathInsertedRoutes, UserInputObjectType.ComboBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_PRESERVE_CUST_SEQUENCE, "Preserve Customer Visit Sequence", new List<object>() { true, false }, true, UserInputObjectType.CheckBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_RANDOM_SEED, "Random Seed", "50"));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_NUM_COLUMNS_ADDED_PER_ITER, "Columns Added Per Iter", "50"));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_SELECTION_CRITERIA, "Random Site Selection Criterion", new List<object>() { Selection_Criteria.CompleteUniform, Selection_Criteria.WeightedNormalizedProbSelection }, Selection_Criteria.WeightedNormalizedProbSelection, UserInputObjectType.ComboBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_TSP_OPTIMIZATION_MODEL_TYPE, "TSP Type", new List<object>() { TSPSolverType.GDVExploiter, TSPSolverType.PlainAFVSolver, TSPSolverType.OldiesADF }, TSPSolverType.GDVExploiter, UserInputObjectType.ComboBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.PROB_BKS, "BKS", "0"));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_FEASIBLE_SUBSOLN_IS_ENOUGH, "Feasible Soln OK", new List<object>() { true, false }, false, UserInputObjectType.CheckBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_PERFORM_SWAP, "Adjacent Swap", new List<object>() { true, false }, true, UserInputObjectType.CheckBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_ADD_INITIAL_COLUMNS, "Add initial cols", new List<object>() { true, false }, true, UserInputObjectType.CheckBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_SHAKE, "Shake", new List<object>() { true, false }, true, UserInputObjectType.CheckBox));
        }
        public override void SpecializedInitialize(EVvsGDV_ProblemModel theProblemModel)
        {

            //Problem param
            this.theProblemModel = theProblemModel;
            numCustomers = theProblemModel.SRD.NumCustomers;
            customerIDs = theProblemModel.GetAllCustomerIDs();
            maxColumnsAddedPerIteration = numCustomers * 5;
            evFixedCost = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.EV).FixedCost;
            gdvFixedCost = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.GDV).FixedCost;
            evVariableCost = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.EV).VariableCostPerMile;
            gdvVariableCost = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.GDV).VariableCostPerMile;

        estimatedLBofAddingCustomer2CSList = new Dictionary<string, Dictionary<CustomerSet, double>>();
            foreach (string customerID in customerIDs)
                estimatedLBofAddingCustomer2CSList.Add(customerID, new Dictionary<CustomerSet, double>());

            //Algorithm param
            runTimeLimitInSeconds = AlgorithmParameters.GetParameter(ParameterID.ALG_RUNTIME_SECONDS).GetDoubleValue();
            preserveCustomerVisitSequence = AlgorithmParameters.GetParameter(ParameterID.ALG_PRESERVE_CUST_SEQUENCE).GetBoolValue();
            randomSeed = AlgorithmParameters.GetParameter(ParameterID.ALG_RANDOM_SEED).GetIntValue();
            random = new Random(randomSeed);
            minColumnsNeededPerIteration = numCustomers; //AlgorithmParameters.GetParameter(ParameterID.ALG_NUM_COLUMNS_ADDED_PER_ITER).GetIntValue();
            selectedCriterion = (Selection_Criteria)AlgorithmParameters.GetParameter(ParameterID.ALG_SELECTION_CRITERIA).Value;
            tspSolverType = (TSPSolverType)AlgorithmParameters.GetParameter(ParameterID.ALG_TSP_OPTIMIZATION_MODEL_TYPE).Value;
            feasibleIsEnough = AlgorithmParameters.GetParameter(ParameterID.ALG_FEASIBLE_SUBSOLN_IS_ENOUGH).GetBoolValue();
            performSwap = AlgorithmParameters.GetParameter(ParameterID.ALG_PERFORM_SWAP).GetBoolValue();
            addInitialCols = AlgorithmParameters.GetParameter(ParameterID.ALG_ADD_INITIAL_COLUMNS).GetBoolValue();
            shake = AlgorithmParameters.GetParameter(ParameterID.ALG_SHAKE).GetBoolValue();
            flowchart = (Exploiting_GDVs_Flowchart)AlgorithmParameters.GetParameter(ParameterID.ALG_FLOWCHART).Value;

            BKS = Double.Parse(GetBKS()); // AlgorithmParameters.GetParameter(ParameterID.PROB_BKS).GetDoubleValue();
            XcplexParam = new XCPlexParameters();

            customerShadowPrices = new Dictionary<string, double>();
            vehicleShadowPrices = new Dictionary<string, double>();
            columns2setCover = new CustomerSetList();
            exploredCustomerSetMasterList = new CustomerSetList();
            exploredCustomerSetMasterListIDs = new List<string>();

            //Solution stat
            status = AlgorithmSolutionStatus.NotYetSolved;
            stats.UpperBound = double.MinValue;
            allSolutions = new List<CustomerSetBasedSolution>();
            incumbentTime = new List<double>();
            iterationNo = new List<int>();
            optStatistics = new List<OptimizationStatistics>();
            cgIterationStatList = new List<CGIterationStats>();
        }
        public override void SpecializedRun()
        {
            int count = 0;//START ALGORITHM
            globalStartTime = DateTime.Now;
            SetInitialColumns(); //INITIALIZE COLUMN GENERATION BY GENERATING SINGLE CUSTOMER ROUTES
            double timelapse1 = (DateTime.Now - globalStartTime).TotalSeconds;
            UpdateShadowPrices(exploredCustomerSetMasterList); //SOLVE THE RELAXED AND RESTRICTED MASTER PROBLEM; UPDATE SHADOW PRICES
            cumulativeTotalTime = (DateTime.Now - globalStartTime).TotalSeconds;
            totalNumOfColumnsExploredSoFar = exploredCustomerSetMasterList.Count;
            cgIterationStatList.Add(new CGIterationStats(iterationNum, totalNumOfColumnsExploredSoFar, 0, numCustomers,
                totalNumOfColumnsExploredSoFar, totalNumOfColumnsExploredSoFar, (cumulativeTotalTime - timelapse1),
                0.0, timelapse1, cumulativeTotalTime, cumulativeTotalTime, cumulativeTotalTime, relaxedSetPartitionObjValue, 1.0));
            //RunIntegerSetCoverAndUpdateSolutionList(count);          
            terminate = false;
            while (!terminate) //KEEP ADDING COLUMNS WHILE TERMINATION CRITERIA IS NOT SATISFIED
            {
                iterationNum++;
                swActual = Stopwatch.StartNew();
                if ((DateTime.Now - globalStartTime).TotalSeconds > runTimeLimitInSeconds) { terminate = true; break; }
                ExploreAndAddNewColumnsNew(); //ADD PREDETERMINED NUMBER OF COLUMNS
                                              //ExploreAndAddNewColumns(); //ADD PREDETERMINED NUMBER OF COLUMNS
                                              //Uncomment the following if you want to add two customers at a time
                                              //if (addTwoAtaTime)
                                              //ExploreAndAddNewColumnsByExtendingTwoCustomers();
                //count++;
                //RunIntegerSetCoverAndUpdateSolutionList(count);
                sw = Stopwatch.StartNew();
                UpdateShadowPrices(exploredCustomerSetMasterList); //SOLVE THE RELAXED AND RESTRICTED MASTER PROBLEM; UPDATE SHADOW PRICES
                //UpdateShadowPrices(columns2setCover);
                relaxedSetPartitionTime = sw.Elapsed.TotalSeconds;
                sw.Reset();
                iterationTotalTimeActual = swActual.Elapsed.TotalSeconds;
                swActual.Reset();
                //TODO record iteration statistics here!
                cumulativeTotalTime = cumulativeTotalTime + iterationTotalTimeActual;
                cgIterationStatList.Add(new CGIterationStats(iterationNum, numberOfColumnsExplored, numberOfNegRedCostColumnsAdded, numberOfPromisingCustomers, numOfColumnsToSetPartitioning, totalNumOfColumnsExploredSoFar, relaxedSetPartitionTime, customerSetGeneratorTotalTime, routeOptimizationTotalTime, iterationTotalTimeCalculated, iterationTotalTimeActual, cumulativeTotalTime, relaxedSetPartitionObjValue, avgNumberOfCustomersExplored));
                if (numberOfColumnsExplored == 0)
                    terminate = true;
            }
            RunIntegerSetCoverAndUpdateSolutionList(count++);   //UPDATE THE INCUMBENT ONE LAST TIME
            globalFinishTime = DateTime.Now;
            totalRunTimeSec = (globalFinishTime - globalStartTime).TotalSeconds; //FINISH ALGORITHM
        }
        public override void SpecializedConclude()
        {
            string outputPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), folder, "Output");
            System.IO.Directory.CreateDirectory(outputPath);
            if (writeAllIncumbentSolns)
            {
                writtenOutput = WriteIncumbentSolutions();
                string toAppendOutput = "_" + flowchart.ToString() + "_profitMaxoutput_" + theProblemModel.GetNumVehicles(VehicleCategories.EV) + "EVs" + randomSeed.ToString() + "_seed";
                File.WriteAllLines(Path.Combine(outputPath, StringOperations.AppendToFilename(theProblemModel.InputFileName, toAppendOutput)), writtenOutput);
            }
            writtenStatistics = WriteSolutionStatistics();
            string toAppendStatistics = "_" + flowchart.ToString() + "_statistics_" + theProblemModel.GetNumVehicles(VehicleCategories.EV) + "EVs" + randomSeed.ToString() + "_seed";
            File.WriteAllLines(StringOperations.AppendToFilename(theProblemModel.InputFileName, toAppendStatistics), writtenStatistics);

            string toAppendSetPartStat = "_" + flowchart.ToString() + "_setPartitioningStats_" + theProblemModel.GetNumVehicles(VehicleCategories.EV) + "EVs" + randomSeed.ToString() + "_seed";
            WriteIterationStatsToFile(StringOperations.AppendToFilename(theProblemModel.InputFileName, toAppendSetPartStat), cgIterationStatList);

            //Given that the instance is solved, we need to update status and statistics from it
            status = (AlgorithmSolutionStatus)((int)setPartitionSolver.SolutionStatus);
            stats.RunTimeMilliSeconds = (long)totalRunTimeSec;
            stats.LowerBound = setPartitionSolver.LowerBound_XCPlex;
            stats.UpperBound = setPartitionSolver.UpperBound_XCPlex;
            //GetOutputSummary();
            //Create solution based on status: Not yet solved, infeasible, no feasible soln found, feasible, optimal
            switch (status)
            {
                case AlgorithmSolutionStatus.NotYetSolved:
                    {
                        //Actual Run Time:N/A, Complete Solution-LB:N/A, Best Solution-UB:N/A, Best Solution Found:N/A
                        bestSolutionFound = new CustomerSetBasedSolution();
                        break;
                    }
                case AlgorithmSolutionStatus.Infeasible://When it is profit maximization, we shouldn't observe this case
                    {
                        //Actual Run Time:Report, Complete Solution-LB:N/A, Best Solution-UB:N/A, Best Solution Found:N/A
                        bestSolutionFound = new CustomerSetBasedSolution();
                        break;
                    }
                case AlgorithmSolutionStatus.NoFeasibleSolutionFound:
                    {
                        //Actual Run Time=Limit:Report, Complete Solution-LB:N/A, Best Solution-UB:N/A, Best Solution Found:N/A
                        bestSolutionFound = new CustomerSetBasedSolution();
                        break;
                    }
                case AlgorithmSolutionStatus.Feasible:
                    {
                        //Actual Run Time=Limit:Report, Complete Solution-LB:Report, Best Solution-UB:Report, Best Solution Found:Report
                        bestSolutionFound = (CustomerSetBasedSolution)setPartitionSolver.GetCompleteSolution(typeof(CustomerSetBasedSolution));
                        break;
                    }
                case AlgorithmSolutionStatus.Optimal:
                    {
                        //Actual Run Time:Report<Limit, Complete Solution-LB = Best Solution-UB:Report, Best Solution Found:Report
                        bestSolutionFound = (CustomerSetBasedSolution)setPartitionSolver.GetCompleteSolution(typeof(CustomerSetBasedSolution));
                        break;
                    }
                default:
                    break;
            }
            bestSolutionFound.Status = status;
            bestSolutionFound.UpperBound = setPartitionSolver.UpperBound_XCPlex;
            bestSolutionFound.LowerBound = setPartitionSolver.LowerBound_XCPlex;
            string toAppend = "_" + flowchart.ToString() + "_OptimizationStatistics_" + theProblemModel.GetNumVehicles(VehicleCategories.EV) + "EVs" + randomSeed.ToString() + "_seed";
            WriteStatsToFile(StringOperations.AppendToFilename(theProblemModel.InputFileName, toAppend), optStatistics);
        }
        public override void SpecializedReset()
        {
            setPartitionSolver.ClearModel();
            setPartitionSolver.Dispose();
            setPartitionSolver.End();
            setPartitionSolver = null;

            relaxedSetPartitionSolver.ClearModel();
            relaxedSetPartitionSolver.Dispose();
            relaxedSetPartitionSolver.End();
            relaxedSetPartitionSolver = null;

            iterationNum = 0; //iteration number

            numberOfColumnsExplored = 0; //columns added to the explored set
            numberOfNegRedCostColumnsAdded = 0; //negative reduced cost columns added to the master set
            numberOfPromisingCustomers = 0; //Customers having >0 shadow prices

            numOfColumnsToSetPartitioning = 0;
            totalNumOfColumnsExploredSoFar = 0;

            relaxedSetPartitionTime = 0.0; //relaxed set partitioning duration
            customerSetGeneratorTotalTime = 0.0;
            customerSetGeneratorLocalTime = 0.0;
            routeOptimizationTotalTime = 0.0; //total duration of the route optimization
            routeOptimizationLocallTime = 0.0;
            iterationTotalTimeActual = 0.0;
            cumulativeTotalTime = 0.0;

            relaxedSetPartitionObjValue = 0.0; //objective function value of the relaxed set partitioning model
            avgNumberOfCustomersExplored = 0.0;

            iter = 0.0;
            totalCustomers = 0.0;

            sw = new Stopwatch();
            swActual = new Stopwatch();

            cgIterationStatList = new List<CGIterationStats>();
            writeAllIncumbentSolns = true;

            //Datatable for estimated reduced costs Dictionary<customerID,Dictionary<
            estimatedLBofAddingCustomer2CSList = new Dictionary<string, Dictionary<CustomerSet, double>>();
            customerIDs = new List<string>();
            evFixedCost = 0.0;
            gdvFixedCost = 0.0;
            evVariableCost = 0.0;
            gdvVariableCost = 0.0;

            //Algorithm parameters
            epsilon = 0.01;
            minColumnsNeededPerIteration = 0;
            maxColumnsAddedPerIteration = 0;
            columnsNeededPerCustomer = 1;
            preserveCustomerVisitSequence = false;
            addInitialCols = false;
            shake = false;

            runTimeLimitInSeconds = 0.0;
            numCustomers=0;
            feasibleIsEnough=false;
            performSwap=false;

            customerShadowPrices = new Dictionary<string, double> ();
            vehicleShadowPrices = new Dictionary<string, double>();

            XcplexParam = new XCPlexParameters();

            columns2setCover = new CustomerSetList();
            exploredCustomerSetMasterList = new CustomerSetList();
            exploredCustomerSetMasterListIDs = new List<string>();


            solution = new CustomerSetBasedSolution();
            allSolutions = new List<CustomerSetBasedSolution>();
            incumbentSolution = new CustomerSetBasedSolution();
            incumbentTime = new List<double>();
            iterationNo = new List<int>();
            BKS = 0.0;
            instanceName = "";

            //Local statistics
            totalRunTimeSec = 0.0;
            optStatistics = new List<OptimizationStatistics>(); ;

            terminate = false;
            GC.Collect();
        }

        //THESE ARE UPDATED METHODS
        void SetInitialColumns()
        {
            for (int i = 0; i < theProblemModel.SRD.NumCustomers; i++)
            {
                CustomerSet singleCustomerCS = new CustomerSet(theProblemModel.GetAllCustomerIDs()[i], theProblemModel.GetAllCustomerIDs());
                columns2setCover.Add(OptimizeCS(singleCustomerCS));
            }
            exploredCustomerSetMasterList.AddRange(columns2setCover);
            if (addInitialCols)
            {
                columns2setCover.AddRange(AddInitialColumnsHeuristically(columns2setCover));
            }
            AddEstimatedLBofAddingCustomer2CustomerSets(columns2setCover);
        }
        CustomerSetList AddInitialColumnsHeuristically(CustomerSetList csList2explore, bool tryAllChildren = false)
        {
            CustomerSetList potentialColumns = new CustomerSetList();
            foreach (CustomerSet cs in csList2explore)
            {
                bool extendable = false;
                if (cs.PossibleOtherCustomers.Count == 0)
                    continue;
                else
                {
                    if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV || cs.RouteOptimizationOutcome.Status==RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV)
                    {
                        extendable = true;
                        CustomerSet currentCS = new CustomerSet(cs);
                        int j = 0;
                        while (extendable)
                        {
                            string[] candidates = SelectACustomer(currentCS);
                            CustomerSet tempCS = new CustomerSet(currentCS);
                            tempCS.NewExtend(candidates[j]);
                            if (exploredCustomerSetMasterList.ContainsCS(tempCS.CustomerSetID))
                                if (tryAllChildren && j < candidates.Length - 1)
                                {
                                    currentCS = new CustomerSet(cs);
                                    j++;
                                    continue;
                                }
                                else
                                    break;
                            OptimizeCS(tempCS);
                            exploredCustomerSetMasterList.Add(tempCS);
                            if (tempCS.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV || cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV)
                            {
                                potentialColumns.Add(tempCS);
                                if (tempCS.PossibleOtherCustomers.Count == 0)
                                    extendable = false;
                                else
                                {
                                    currentCS = new CustomerSet(tempCS);
                                    j = 0;
                                }
                            }
                            else
                                extendable = false;
                            if ((DateTime.Now - globalStartTime).TotalSeconds > runTimeLimitInSeconds)
                            {
                                extendable = false;
                                terminate = true;
                            }
                        }

                    }
                }
                if (terminate)
                    break;
            }
            return potentialColumns;
        }

        string[] SelectACustomer(CustomerSet currentCS)
        {
            string[] VisitableCustomers = currentCS.PossibleOtherCustomers.ToArray();
            double[] key = new double[currentCS.PossibleOtherCustomers.Count];

            switch (selectedCriterion)
            {
                case Selection_Criteria.CompleteUniform:
                    for (int i = 0; i < VisitableCustomers.Length; i++)
                        key[i] = random.NextDouble();
                    Array.Sort(key, VisitableCustomers);
                    return VisitableCustomers;

                case Selection_Criteria.WeightedNormalizedProbSelection:
                    //We assume probabilities are proportional inverse distances
                    double[] prob = new double[VisitableCustomers.Length];
                    double probSum = 0.0;
                    for (int c = 0; c < VisitableCustomers.Length; c++)
                    {
                        prob[c] = 1.0 / Math.Max(0.00001, ShortestDistanceOfCandidateToCurrentCustomerSet(currentCS, VisitableCustomers[c]));//Math.max used to eliminate the div by 0 error
                        prob[c] = Math.Pow(prob[c], 2);
                        probSum += prob[c];
                    }
                    for (int c = 0; c < VisitableCustomers.Length; c++)
                        prob[c] /= probSum;
                    Array.Sort(prob, VisitableCustomers);
                    Array.Reverse(VisitableCustomers);

                    return VisitableCustomers;//[Utils.RandomArrayOperations.Select(random.NextDouble(), prob)];

                default:
                    throw new Exception("The selection criterion sent to CustomerSet.Extend was not defined before!");
            }

        }
        List<string> PopulateTheBestTopXPercentCustomersList(CustomerSet CS, List<string> VisitableCustomers, double closestPercentSelect)
        {
            string[] customers = VisitableCustomers.ToArray();
            int nCustomers = customers.Length;
            double[] shortestDistancesToCS = new double[nCustomers];
            for (int i = 0; i < nCustomers; i++)
            {
                shortestDistancesToCS[i] = ShortestDistanceOfCandidateToCurrentCustomerSet(CS, customers[i]);
            }
            Array.Sort(shortestDistancesToCS, customers);

            List<string> outcome = new List<string>();
            int numberToReturn = (int)Math.Ceiling(closestPercentSelect * nCustomers / 100.0);
            for (int i = 0; i < numberToReturn; i++)
            {
                outcome.Add(customers[i]);
            }

            return outcome;
        }
        double ShortestDistanceOfCandidateToCurrentCustomerSet(CustomerSet CS, string candidate)
        {
            if (CS.NumberOfCustomers == 0)
                return theProblemModel.SRD.GetDistance(candidate, theProblemModel.SRD.GetSingleDepotID());
            else
            {
                double outcome = double.MaxValue;
                foreach (string customer in CS.Customers)
                {
                    double distance = theProblemModel.SRD.GetDistance(candidate, customer);
                    if (outcome > distance)
                    {
                        outcome = distance;
                    }
                }
                return outcome;
            }
        }
        CustomerSet OptimizeCS(CustomerSet cs)
        {
            if (tspSolverType == TSPSolverType.GDVExploiter)
            {
                cs.OptimizeByExploitingGDVs(theProblemModel, flowchart, preserveCustomerVisitSequence, feasibleIsEnough, performSwap);
                optStatistics.Add(theProblemModel.RetrieveExploitingGDVoptStat());
            }
            else if (tspSolverType == TSPSolverType.PlainAFVSolver)
            {
                cs.OptimizeByPlainAFVSolver(theProblemModel, flowchart);
                optStatistics.Add(theProblemModel.RetrievePlainOptStat());
            }
            else
                cs.NewOptimize(theProblemModel);
            return cs;
        }
        void ExploreAndAddNewColumnsNew()
        {
            double successRate = 1.0;
            sw = Stopwatch.StartNew();
            int positiveReducedCostColumCount = 0;
            int numExploredCSs1 = exploredCustomerSetMasterList.Count();
            //CustomerSetList newColumns = new CustomerSetList();
            List<string> sortedPotentialCustomerIDs = GetSortedPotentialCustomerIDs(); //SORT PROMISING CUSTOMERS IN DESCENDING SHADOW PRICES   
            numberOfPromisingCustomers = sortedPotentialCustomerIDs.Count();
            iter = 0.0;
            totalCustomers = 0.0;
            CustomerSetList potentialColumns = new CustomerSetList();
            CustomerSetList additionalColumns = new CustomerSetList();

            List<Tuple<string, CustomerSet, double>> columns2explore = GetEstimatedPositiveReducedCostCustomerSets(minColumnsNeededPerIteration);
            customerSetGeneratorTotalTime = sw.Elapsed.TotalSeconds;
            sw.Reset();
            //EXPLORE THE CUSTOMER + CUSTOMER SET PAIR USING THE SELECTED METHOD
            sw = Stopwatch.StartNew();
            for (int i = 0; i < columns2explore.Count; i++)
            {
                CustomerSet tempCS = new CustomerSet(columns2explore[i].Item2);
                tempCS.NewExtend(columns2explore[i].Item1);
                if ((DateTime.Now - globalStartTime).TotalSeconds > runTimeLimitInSeconds) { terminate = true; break; }
                OptimizeCS(tempCS);
                if (tempCS.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV || tempCS.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV)
                {
                    potentialColumns.Add(tempCS);
                    if (GetShadowPricesInCS(tempCS)+vehicleShadowPrices["EV"] < tempCS.OFIDP.GetPrizeCollected(VehicleCategories.EV)-evFixedCost- evVariableCost* tempCS.OFIDP.GetVMT(VehicleCategories.EV))
                    {
                        positiveReducedCostColumCount++;
                        successRate = (double)positiveReducedCostColumCount / (double)potentialColumns.Count();
                    }
                    else if (GetShadowPricesInCS(tempCS) < tempCS.OFIDP.GetPrizeCollected(VehicleCategories.GDV) - gdvFixedCost - tempCS.OFIDP.GetVMT(VehicleCategories.GDV))
                    {
                        positiveReducedCostColumCount++;
                        successRate = (double)positiveReducedCostColumCount / (double)potentialColumns.Count();
                    }
                    else
                        additionalColumns.Add(tempCS);
                }
                iter = iter + 1.0;
                totalCustomers = totalCustomers + tempCS.Customers.Count;
                exploredCustomerSetMasterList.Add(tempCS);
                if ((potentialColumns.Count() > minColumnsNeededPerIteration && successRate <= 0.5) || positiveReducedCostColumCount >= maxColumnsAddedPerIteration)
                    break;
            }

            if (shake)
            {
                if (additionalColumns.Count > positiveReducedCostColumCount)
                    potentialColumns.AddRange(AddInitialColumnsHeuristically(additionalColumns, true));
            }
            if (potentialColumns.Count > 0 && !terminate)
            {
                AddEstimatedLBofAddingCustomer2CustomerSets(potentialColumns);
            }
            else
            {
                terminate = true;
            }
            routeOptimizationTotalTime = sw.Elapsed.TotalSeconds;
            sw.Reset();
            sw = Stopwatch.StartNew();
            avgNumberOfCustomersExplored = totalCustomers / iter;
            //columns2setCover.AddRange(potentialColumns);
            numberOfNegRedCostColumnsAdded = positiveReducedCostColumCount;
            numOfColumnsToSetPartitioning = numOfColumnsToSetPartitioning + potentialColumns.Count();
            totalNumOfColumnsExploredSoFar = exploredCustomerSetMasterList.Count();
            numberOfColumnsExplored = totalNumOfColumnsExploredSoFar - numExploredCSs1;
        }

        CustomerSetBasedSolution SetCover(CustomerSetList columnsToSetCover)
        {
            setPartitionSolver = new XCPlex_SetCovering_wCustomerSets(theProblemModel, XcplexParam, columnsToSetCover, noGDVUnlimitedEV: false);
            setPartitionSolver.Solve_and_PostProcess();

            CustomerSetBasedSolution outcome = (CustomerSetBasedSolution)setPartitionSolver.GetCompleteSolution(typeof(CustomerSetBasedSolution));
            if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.Feasible)
                outcome.Status = AlgorithmSolutionStatus.Feasible;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.Infeasible)
                outcome.Status = AlgorithmSolutionStatus.Infeasible;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.NoFeasibleSolutionFound)
                outcome.Status = AlgorithmSolutionStatus.NoFeasibleSolutionFound;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.NotYetSolved)
                outcome.Status = AlgorithmSolutionStatus.NotYetSolved;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.Optimal)
                outcome.Status = AlgorithmSolutionStatus.Optimal;

            outcome.UpperBound = setPartitionSolver.UpperBound_XCPlex;
            outcome.LowerBound = setPartitionSolver.LowerBound_XCPlex;
            return outcome;
        }
        void UpdateShadowPrices(CustomerSetList columnsToSetCover)
        {
            relaxedSetPartitionSolver = new XCPlex_SetCovering_wCustomerSets(theProblemModel, new XCPlexParameters(relaxation: XCPlexRelaxation.LinearProgramming), columnsToSetCover, noGDVUnlimitedEV: false);
            relaxedSetPartitionSolver.Solve_and_PostProcess();
            relaxedSetPartitionObjValue = relaxedSetPartitionSolver.UpperBound_XCPlex;
            customerShadowPrices = relaxedSetPartitionSolver.GetCustomerCoverageConstraintShadowPrices();
            vehicleShadowPrices = relaxedSetPartitionSolver.GetNumberOfVehiclesLimitShadowPrices();
        }
       
        List<string> GetSortedPotentialCustomerIDs()
        {
            var temp = (from entry in customerShadowPrices orderby entry.Value ascending select entry);
            return temp.Where(x => x.Value < 0).Select(x => x.Key).ToList();
        }

        double GetShadowPricesInCS(CustomerSet cs)
        {
            double outcome = 0;
            foreach (string id in cs.Customers)
                outcome += customerShadowPrices[id];
            return outcome;
        }
        double GetShadowPriceOfAVehicle(VehicleCategories vc = VehicleCategories.EV)
        {
            if (vc == VehicleCategories.EV)
                return vehicleShadowPrices["EV"];
            else if (vc == VehicleCategories.GDV)
                return vehicleShadowPrices["GDV"];
            else
                throw new Exception("Unknown vehicle category invoked.");
        }

        void RunIntegerSetCoverAndUpdateSolutionList(int count)
        {
            solution = SetCover(exploredCustomerSetMasterList);
            //solution = SetCover(columns2setCover);
            if (solution.Status == AlgorithmSolutionStatus.Optimal)
            {
                if (count == 0 || incumbentSolution.UpperBound < solution.UpperBound)
                {
                    allSolutions.Add(solution);
                    iterationNo.Add(count);
                    incumbentTime.Add((DateTime.Now - globalStartTime).TotalSeconds);
                    incumbentSolution = solution;
                    //if (solution.UpperBound - BKS  <= epsilon)
                    //optIsFound = true;
                }
            }
        }

        List<Tuple<string, CustomerSet, double>> GetEstimatedPositiveReducedCostCustomerSets(int minimumColumnNum)
        {
            CustomerSetList customerSets = new CustomerSetList();
            List<Tuple<string, CustomerSet, double>> estimatedReducedCostTuples = new List<Tuple<string, CustomerSet, double>>();
            foreach (string customerID in customerIDs)
            {
                double SPofCustomer = customerShadowPrices[customerID];
                foreach (KeyValuePair<CustomerSet, double> kvp in estimatedLBofAddingCustomer2CSList[customerID])
                {
                    double newCost = 0;
                    if (kvp.Key.GetVehicleSpecificRouteOptimizationStatus(VehicleCategories.EV)==VehicleSpecificRouteOptimizationStatus.Optimized)
                        newCost = kvp.Value - GetShadowPricesInCS(kvp.Key) - SPofCustomer - GetShadowPriceOfAVehicle();
                    else if(kvp.Key.GetVehicleSpecificRouteOptimizationStatus(VehicleCategories.GDV) == VehicleSpecificRouteOptimizationStatus.Optimized)
                        newCost = kvp.Value - GetShadowPricesInCS(kvp.Key) - SPofCustomer;
                    estimatedReducedCostTuples.Add(Tuple.Create(customerID, kvp.Key, newCost));
                }
            }
            estimatedReducedCostTuples = estimatedReducedCostTuples.OrderByDescending(x => x.Item3).ToList();
            return estimatedReducedCostTuples;
        }

        void AddEstimatedLBofAddingCustomer2CustomerSets(CustomerSetList customerSets)
        {
            foreach (CustomerSet cs in customerSets)
                foreach (string customerID in cs.PossibleOtherCustomers)
                {
                    if (cs.RouteOptimizationOutcome.Status != RouteOptimizationStatus.OptimizedForBothGDVandEV && cs.RouteOptimizationOutcome.Status != RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV && cs.RouteOptimizationOutcome.Status != RouteOptimizationStatus.OptimizedForGDVButNotYetOptimizedForEV)
                    {
                        continue;
                    }
                    List<string> extendedCScustomers = new List<string>(cs.Customers);
                    extendedCScustomers.Add(customerID);
                    string csID = String.Join(",", extendedCScustomers.OrderBy(x => x));
                    if (ConsistsOfSameCustomers(csID))
                    {
                        continue;
                    }
                    else
                    {
                        exploredCustomerSetMasterListIDs.Add(csID);
                        double estimatedReducedCost = Double.MinValue;
                        if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV)
                        {
                            double estimatedReducedCostofGDV = (cs.OFIDP.GetPrizeCollected(VehicleCategories.GDV) + theProblemModel.SRD.GetSiteByID(customerID).GetPrize(VehicleCategories.GDV)) - gdvFixedCost - gdvVariableCost*(cs.OFIDP.GetVMT(VehicleCategories.GDV) + cs.GetShortestTwoArcsToCSfromCustomerID(customerID, theProblemModel) - cs.GetLongestArc(VehicleCategories.GDV));
                            double estimatedReducedCostofEV = (cs.OFIDP.GetPrizeCollected(VehicleCategories.EV) + theProblemModel.SRD.GetSiteByID(customerID).GetPrize(VehicleCategories.EV)) - evFixedCost - evVariableCost*(cs.OFIDP.GetVMT(VehicleCategories.EV) + cs.GetShortestTwoArcsToCSfromCustomerID(customerID, theProblemModel) - cs.GetLongestArc());
                            estimatedReducedCost = Math.Max(estimatedReducedCostofGDV, estimatedReducedCostofEV);
                        }
                        else if(cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV || cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButNotYetOptimizedForEV)
                        {
                            estimatedReducedCost = (cs.OFIDP.GetPrizeCollected(VehicleCategories.GDV) + theProblemModel.SRD.GetSiteByID(customerID).GetPrize(VehicleCategories.GDV)) - gdvFixedCost - gdvVariableCost*(cs.OFIDP.GetVMT(VehicleCategories.GDV) + cs.GetShortestTwoArcsToCSfromCustomerID(customerID, theProblemModel) - cs.GetLongestArc(VehicleCategories.GDV));
                        }
                        estimatedLBofAddingCustomer2CSList[customerID].Add(cs, estimatedReducedCost);
                    }
                }
        }
        bool ConsistsOfSameCustomers(string potentialCSID)
        {
            foreach (string id in exploredCustomerSetMasterListIDs)
                if (id == potentialCSID)
                    return true;
            return false;
        }
        //void AddInitialEstimatedLBofAddingCustomer2CustomerSets(CustomerSetList customerSets)
        //{
        //    foreach (string customerID in customerIDs)
        //    {
        //        foreach (CustomerSet cs in customerSets)
        //        {
        //            bool csExists = false;
        //            for (int i = 0; i < estimatedLBofAddingCustomer2CSList[customerID].Keys.Count; i++)
        //                if (estimatedLBofAddingCustomer2CSList[customerID].Keys.ToList()[i].CustomerSetID == cs.CustomerSetID)
        //                {
        //                    csExists = true;
        //                    break;
        //                }
        //            if (csExists)
        //                continue;
        //            if (cs.Contains(customerID) || cs.ImpossibleOtherCustomers.Contains(customerID)
        //                 || cs.RouteOptimizationOutcome.Status != RouteOptimizationStatus.OptimizedForBothGDVandEV
        //                 || cs.RouteOptimizationOutcome.Status != RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV
        //                 || cs.RouteOptimizationOutcome.Status != RouteOptimizationStatus.OptimizedForGDVButNotYetOptimizedForEV)
        //                {
        //                    estimatedLBofAddingCustomer2CSList[customerID].Add(cs, double.MinValue);
        //                    continue;
        //                }
        //                else
        //                {
        //                double estimatedReducedCost = Double.MinValue;
        //                if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV)
        //                {
        //                    double estimatedReducedCostofGDV = (cs.OFIDP.GetPrizeCollected(VehicleCategories.GDV) + theProblemModel.SRD.GetSiteByID(customerID).GetPrize(VehicleCategories.GDV)) - gdvFixedCost - gdvVariableCost * (cs.OFIDP.GetVMT(VehicleCategories.GDV) + cs.GetShortestTwoArcsToCSfromCustomerID(customerID, theProblemModel) - cs.GetLongestArc());
        //                    double estimatedReducedCostofEV = (cs.OFIDP.GetPrizeCollected(VehicleCategories.EV) + theProblemModel.SRD.GetSiteByID(customerID).GetPrize(VehicleCategories.EV)) - evFixedCost - evVariableCost * (cs.OFIDP.GetVMT(VehicleCategories.EV) + cs.GetShortestTwoArcsToCSfromCustomerID(customerID, theProblemModel) - cs.GetLongestArc());
        //                    estimatedReducedCost = Math.Max(estimatedReducedCostofGDV, estimatedReducedCostofEV);
        //                }
        //                else if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV || cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButNotYetOptimizedForEV)
        //                {
        //                    estimatedReducedCost = (cs.OFIDP.GetPrizeCollected(VehicleCategories.GDV) + theProblemModel.SRD.GetSiteByID(customerID).GetPrize(VehicleCategories.GDV)) - gdvFixedCost - gdvVariableCost * (cs.OFIDP.GetVMT(VehicleCategories.GDV) + cs.GetShortestTwoArcsToCSfromCustomerID(customerID, theProblemModel) - cs.GetLongestArc());
        //                }

        //            }
        //        }
        //    }
        //}

        //DO NOT TOUCH THESE FOR NOW!!!
        string GetBKS()
        {
            double bestKnownSoln;
            if (theProblemModel.InputFileName.Contains("AB101"))
            {
                bestKnownSoln = 2566.62;
                instanceName = "AB101";
            }
            else if (theProblemModel.InputFileName.Contains("AB102"))
            {
                bestKnownSoln = 2876.26;
                instanceName = "AB102";
            }
            else if (theProblemModel.InputFileName.Contains("AB103"))
            {
                bestKnownSoln = 2804.07;
                instanceName = "AB103";
            }
            else if (theProblemModel.InputFileName.Contains("AB104"))
            {
                bestKnownSoln = 2634.17;
                instanceName = "AB104";
            }
            else if (theProblemModel.InputFileName.Contains("AB105"))
            {
                bestKnownSoln = 3939.96;
                instanceName = "AB105";
            }
            else if (theProblemModel.InputFileName.Contains("AB106"))
            {
                bestKnownSoln = 3915.15;
                instanceName = "AB106";
            }
            else if (theProblemModel.InputFileName.Contains("AB107"))
            {
                bestKnownSoln = 3732.97;
                instanceName = "AB107";
            }
            else if (theProblemModel.InputFileName.Contains("AB108"))
            {
                bestKnownSoln = 3672.4;
                instanceName = "AB108";
            }
            else if (theProblemModel.InputFileName.Contains("AB109"))
            {
                bestKnownSoln = 3722.17;
                instanceName = "AB109";
            }
            else if (theProblemModel.InputFileName.Contains("AB110"))
            {
                bestKnownSoln = 3612.95;
                instanceName = "AB110";
            }
            else if (theProblemModel.InputFileName.Contains("AB111"))
            {
                bestKnownSoln = 3996.96;
                instanceName = "AB111";
            }
            else if (theProblemModel.InputFileName.Contains("AB112"))
            {
                bestKnownSoln = 5487.87;
                instanceName = "AB112";
            }
            else if (theProblemModel.InputFileName.Contains("AB113"))
            {
                bestKnownSoln = 4804.62;
                instanceName = "AB113";
            }
            else if (theProblemModel.InputFileName.Contains("AB114"))
            {
                bestKnownSoln = 5324.17;
                instanceName = "AB114";
            }
            else if (theProblemModel.InputFileName.Contains("AB115"))
            {
                bestKnownSoln = 5035.35;
                instanceName = "AB115";
            }
            else if (theProblemModel.InputFileName.Contains("AB116"))
            {
                bestKnownSoln = 4511.64;
                instanceName = "AB116";
            }
            else if (theProblemModel.InputFileName.Contains("AB117"))
            {
                bestKnownSoln = 5370.28;
                instanceName = "AB117";
            }
            else if (theProblemModel.InputFileName.Contains("AB118"))
            {
                bestKnownSoln = 5756.88;
                instanceName = "AB118";
            }
            else if (theProblemModel.InputFileName.Contains("AB119"))
            {
                bestKnownSoln = 5599.96;
                instanceName = "AB119";
            }
            else if (theProblemModel.InputFileName.Contains("AB120"))
            {
                bestKnownSoln = 5679.81;
                instanceName = "AB120";
            }
            else if (theProblemModel.InputFileName.Contains("AB201"))
            {
                bestKnownSoln = 1836.25;
                instanceName = "AB201";
            }
            else if (theProblemModel.InputFileName.Contains("AB202"))
            {
                bestKnownSoln = 1966.82;
                instanceName = "AB202";
            }
            else if (theProblemModel.InputFileName.Contains("AB203"))
            {
                bestKnownSoln = 1921.59;
                instanceName = "AB203";
            }
            else if (theProblemModel.InputFileName.Contains("AB204"))
            {
                bestKnownSoln = 2001.7;
                instanceName = "AB204";
            }
            else if (theProblemModel.InputFileName.Contains("AB205"))
            {
                bestKnownSoln = 2793.01;
                instanceName = "AB205";
            }
            else if (theProblemModel.InputFileName.Contains("AB206"))
            {
                bestKnownSoln = 2891.48;
                instanceName = "AB206";
            }
            else if (theProblemModel.InputFileName.Contains("AB207"))
            {
                bestKnownSoln = 2717.34;
                instanceName = "AB207";
            }
            else if (theProblemModel.InputFileName.Contains("AB208"))
            {
                bestKnownSoln = 2552.18;
                instanceName = "AB208";
            }
            else if (theProblemModel.InputFileName.Contains("AB209"))
            {
                bestKnownSoln = 2517.69;
                instanceName = "AB209";
            }
            else if (theProblemModel.InputFileName.Contains("AB210"))
            {
                bestKnownSoln = 2479.97;
                instanceName = "AB210";
            }
            else if (theProblemModel.InputFileName.Contains("AB211"))
            {
                bestKnownSoln = 2977.73;
                instanceName = "AB211";
            }
            else if (theProblemModel.InputFileName.Contains("AB212"))
            {
                bestKnownSoln = 3341.43;
                instanceName = "AB212";
            }
            else if (theProblemModel.InputFileName.Contains("AB213"))
            {
                bestKnownSoln = 3133.24;
                instanceName = "AB213";
            }
            else if (theProblemModel.InputFileName.Contains("AB214"))
            {
                bestKnownSoln = 3384.28;
                instanceName = "AB214";
            }
            else if (theProblemModel.InputFileName.Contains("AB215"))
            {
                bestKnownSoln = 3480.52;
                instanceName = "AB215";
            }
            else if (theProblemModel.InputFileName.Contains("AB216"))
            {
                bestKnownSoln = 3221.78;
                instanceName = "AB216";
            }
            else if (theProblemModel.InputFileName.Contains("AB217"))
            {
                bestKnownSoln = 3714.94;
                instanceName = "AB217";
            }
            else if (theProblemModel.InputFileName.Contains("AB218"))
            {
                bestKnownSoln = 3658.17;
                instanceName = "AB218";
            }
            else if (theProblemModel.InputFileName.Contains("AB219"))
            {
                bestKnownSoln = 3790.71;
                instanceName = "AB219";
            }
            else if (theProblemModel.InputFileName.Contains("AB220"))
            {
                bestKnownSoln = 3737.88;
                instanceName = "AB220";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU1_"))
            {
                bestKnownSoln = 1797.49;
                instanceName = "EMH01";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU2"))
            {
                bestKnownSoln = 1574.78;
                instanceName = "EMH02";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU3"))
            {
                bestKnownSoln = 1704.48;
                instanceName = "EMH03";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU4"))
            {
                bestKnownSoln = 1482.00;
                instanceName = "EMH04";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU5"))
            {
                bestKnownSoln = 1689.37;
                instanceName = "EMH05";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU6"))
            {
                bestKnownSoln = 1618.65;
                instanceName = "EMH06";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU7"))
            {
                bestKnownSoln = 1713.66;
                instanceName = "EMH07";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU8"))
            {
                bestKnownSoln = 1706.50;
                instanceName = "EMH08";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU9"))
            {
                bestKnownSoln = 1708.82;
                instanceName = "EMH09";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU10"))
            {
                bestKnownSoln = 1181.31;
                instanceName = "EMH10";
            }
            else if (theProblemModel.InputFileName.Contains("Large VA Input_100"))
            {
                bestKnownSoln = 0.0;
                instanceName = "EMH100";
            }
            else if (theProblemModel.InputFileName.Contains("Large VA Input_111c"))
            {
                bestKnownSoln = 0.0;
                instanceName = "EMH111";
            }
            else if (theProblemModel.InputFileName.Contains("Large VA Input_200c"))
            {
                bestKnownSoln = 0.0;
                instanceName = "EMH200";
            }
            else if (theProblemModel.InputFileName.Contains("Large VA Input_300c"))
            {
                bestKnownSoln = 0.0;
                instanceName = "EMH300";
            }
            else if (theProblemModel.InputFileName.Contains("Large VA Input_400c"))
            {
                bestKnownSoln = 0.0;
                instanceName = "EMH400";
            }
            else if (theProblemModel.InputFileName.Contains("Large VA Input_500c"))
            {
                bestKnownSoln = 0.0;
                instanceName = "EMH500";
            }
            else
            {
                bestKnownSoln = 0.0;
                instanceName = "YC";
            }
            //throw new Exception("AB101-220 must be solved first.");
            return bestKnownSoln.ToString();
        }
        public override string GetName()
        {
            return "Profit Max CGA with Exploiting GDVs";

        }
        public override string[] GetOutputSummary()
        {
            List<string> list = new List<string>{
                 //Algorithm Name has to be the first entry for output file name purposes
                "Algorithm Name: " + GetName(),
                //Run time limit has to be the second entry for output file name purposes
                "Parameter: " + algorithmParameters.GetParameter(ParameterID.ALG_RUNTIME_SECONDS).Description + "-" + algorithmParameters.GetParameter(ParameterID.ALG_RUNTIME_SECONDS).Value.ToString(),
                
                //Optional
                "Parameter: ",
                //algorithmParameters.GetAllParameters();
                //var asString = string.Join(";", algorithmParameters.GetAllParameters());
                //list.Add(asString);
                
                //Necessary statistics
                "CPU Run Time(sec): " + stats.RunTimeMilliSeconds.ToString(),
                "Solution Status: " + status.ToString()
            };
            switch (status)
            {
                case AlgorithmSolutionStatus.NotYetSolved:
                    {
                        break;
                    }
                case AlgorithmSolutionStatus.Infeasible://When it is profit maximization, we shouldn't observe this case
                    {
                        break;
                    }
                case AlgorithmSolutionStatus.NoFeasibleSolutionFound:
                    {
                        break;
                    }
                default:
                    {
                        list.Add("UB(Best Int): " + stats.UpperBound.ToString());
                        list.Add("LB(Relaxed): " + stats.LowerBound.ToString());
                        break;
                    }
            }
            string[] toReturn = new string[list.Count];
            toReturn = list.ToArray();
            return toReturn;
        }
        public override bool setListener(IListener listener)
        {
            throw new NotImplementedException();
        }
        string[] WriteIncumbentSolutions()
        {
            string alg = "";
            switch (flowchart)
            {
                case Exploiting_GDVs_Flowchart.a_NoExploiting:
                    alg = "No Exploiting";
                    break;
                case Exploiting_GDVs_Flowchart.b_OnlyIdenticalRoutes:
                    alg = "Only Identical Routes";
                    break;
                case Exploiting_GDVs_Flowchart.c_PathInsertedRoutes:
                    alg = "Path Inserted Routes";
                    break;
                case Exploiting_GDVs_Flowchart.d_PathInsertedAndSwappedRoutes:
                    alg = "Path Inserted And Swapped Routes";
                    break;
                case Exploiting_GDVs_Flowchart.e_DataCollection:
                    alg = "Data Collection";
                    break;
            }
            string instanceSize = "";
            string instanceType = "";
            if (theProblemModel.InputFileName.Contains("AB"))
                instanceType = "AB";
            else if (theProblemModel.InputFileName.Contains("20c3"))
                instanceType = "EMH";
            if (numCustomers <= 20)
                instanceSize = "XS";
            else if (numCustomers <= 50)
                instanceSize = "S";
            else if (numCustomers <= 75)
                instanceSize = "M";
            else if (numCustomers <= 100)
                instanceSize = "L";
            else if (numCustomers <= 200)
                instanceSize = "XL";
            else if (numCustomers <= 300)
                instanceSize = "XXL";
            else
                instanceSize = "XXXL";

            Vehicle theEV = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.EV);
            Vehicle theGDV = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.GDV);

            double evDrivingRange = theEV.BatteryCapacity / theEV.ConsumptionRate;
            int numESs = theProblemModel.SRD.NumES;
            double ESrefuelingRate = Math.Min(theProblemModel.SRD.GetSitesList(SiteTypes.ExternalStation)[0].RechargingRate, theEV.MaxChargingRate);
            double ISrefuelingRate = 0.0;
            double basePrize = 0.0;
            int numISs = 0;
            int numPremiumPayingCust = 0;
            double premiumIncrease = 0.0;
            List<string> ISCustomersList = new List<string>();
            List<string> EVPremPayingCustomersList = new List<string>();
            foreach(Site s in theProblemModel.SRD.GetSitesList(SiteTypes.Customer))
            {
                if (s.RechargingRate > 0.0)
                {
                    numISs++;
                    ISCustomersList.Add(s.ID);
                    if (ISrefuelingRate < s.RechargingRate)
                        ISrefuelingRate = s.RechargingRate;
                }
                if (s.GetPrize(VehicleCategories.GDV) < s.GetPrize(VehicleCategories.EV))
                {
                    EVPremPayingCustomersList.Add(s.ID);
                    premiumIncrease = s.GetPrize(VehicleCategories.EV) - s.GetPrize(VehicleCategories.GDV);
                    numPremiumPayingCust++;
                }
                if (basePrize < s.GetPrize(VehicleCategories.GDV))
                    basePrize = s.GetPrize(VehicleCategories.GDV);
            }
            double premiumPercentIncrease = premiumIncrease / Math.Max(basePrize, 0.00001); // To avoid div by zero
            double avgSpeed = theProblemModel.CRD.TravelSpeed;
            int numEVs = theProblemModel.GetNumVehicles(VehicleCategories.EV);
            List<string> output = new List<string>();
            output.Add("SolutionID\tAlgorithm\tInstanceType\tInstanceName\tInstanceSize\t" +
                "NumCustomers\tNumESs\tDmax\tEStech\tIStech\tAvgSpeed\t" +
                "FixedAFVCostParam\tFixedGDVCostParam\tVariableAFVCostParam\tVariableGDVCostParam\tBasePrizeParam\t" +
                "NumAvailableAFVs\tNumISs\tNumPremiumPayingCust\tPremiumPercentInc\t" +
                "RouteID\tCustomerSet\tRoute\tVehicle\tNumCustomersPerRoute\tNumISCustomersPerRoute\tNumEVPremCustomersPerRoute\tNumESVisitPerRoute\tVMT\t" +
                "PrizeCollectedPerRoute\tVariableCostPerRoute\tFixedCostPerRoute\t" +
                "TotalNumCustomersServed\tAvticeESs\tTotalNumActiveESs\tTotalNumActiveAFVs\tTotalNumActiveGDVs\t" +
                "TotalAFVPrizeCollected\tTotalGDVPrizeCollected\tTotalAFVVariableCost\tTotalGDVVariableCost\tTotalAFVFixedCost\tTotalGDVFixedCost\tTotalProfit");
            for (int i = 0; i < allSolutions.Count; i++)
            {
                CustomerSetBasedSolution solution = allSolutions[i];
                int routeID = 0;
                int totalCustomersServed = 0;
                double totalEVRoutesPrizes = 0.0;
                double totalGDVRoutesPrizes = 0.0;
                double totalEVVarCost = 0.0;
                double totalGDVVarCost = 0.0;

                List<string> allESs = new List<string>();
                for (int r = 0; r < solution.Assigned2EV.Count; r++)
                {
                    VehicleSpecificRouteOptimizationOutcome vsroo_ev = solution.Assigned2EV[r].RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV);
                    totalCustomersServed = totalCustomersServed + vsroo_ev.VSOptimizedRoute.NumberOfCustomersVisited;
                    totalEVRoutesPrizes = totalEVRoutesPrizes + vsroo_ev.VSOptimizedRoute.GetPrizeCollected();
                    if(vsroo_ev.VSOptimizedRoute.NumberOfSitesVisited - vsroo_ev.VSOptimizedRoute.NumberOfCustomersVisited>0)
                    {
                        allESs.AddRange(vsroo_ev.VSOptimizedRoute.ListOfVisitedNonDepotSiteIDs.Except(vsroo_ev.VSOptimizedRoute.ListOfVisitedCustomerSiteIDs));
                    }
                    totalEVVarCost = totalEVVarCost + vsroo_ev.VSOptimizedRoute.GetVehicleMilesTraveled() * evVariableCost;
                }               
                for (int r = 0; r < solution.Assigned2GDV.Count; r++)
                {
                    VehicleSpecificRouteOptimizationOutcome vsroo_gdv = solution.Assigned2GDV[r].RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV);
                    totalCustomersServed = totalCustomersServed + vsroo_gdv.VSOptimizedRoute.NumberOfCustomersVisited;
                    totalGDVRoutesPrizes = totalGDVRoutesPrizes + vsroo_gdv.VSOptimizedRoute.GetPrizeCollected();
                    totalGDVVarCost = totalGDVVarCost + vsroo_gdv.VSOptimizedRoute.GetVehicleMilesTraveled() * gdvVariableCost;

                }

                List<string> activeESs = allESs.Distinct().ToList();
                double totalNumActiveESs = activeESs.Count;
                string ActiveESs = String.Join("-", activeESs);
                int evRouteCount = solution.Assigned2EV.Count;
                int gdvRouteCount = solution.Assigned2GDV.Count;

                double totalEVFixedCost = evRouteCount * evFixedCost;
                double totalGDVFixedCost = gdvRouteCount * gdvFixedCost;
                double totalProfit = totalEVRoutesPrizes + totalGDVRoutesPrizes - totalEVFixedCost - totalGDVFixedCost - totalEVVarCost - totalGDVVarCost;
                for (int r = 0; r < solution.Assigned2EV.Count; r++)
                {
                    routeID++;
                    VehicleSpecificRouteOptimizationOutcome vsroo_ev = solution.Assigned2EV[r].RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV);
                    string routeEV = String.Join("-", vsroo_ev.VSOptimizedRoute.ListOfVisitedSiteIncludingDepotIDs);
                    string CS = String.Join("-", vsroo_ev.VSOptimizedRoute.ListOfVisitedCustomerSiteIDs);

                    int numCustomersEVroute = vsroo_ev.VSOptimizedRoute.NumberOfCustomersVisited;
                    int numESVisitPerEVRoute = vsroo_ev.VSOptimizedRoute.ListOfVisitedNonDepotSiteIDs.Count - vsroo_ev.VSOptimizedRoute.NumberOfCustomersVisited;
                    double evVMT = vsroo_ev.VSOptimizedRoute.GetVehicleMilesTraveled();
                    double prizeCollectedPerRoute = vsroo_ev.VSOptimizedRoute.GetPrizeCollected();
                    double variableCostPerRoute = evVMT * evVariableCost;
                    int numISCustomersPerRoute = 0;
                    int numEVPremCustomersPerRoute = 0;
                    foreach (string csID in vsroo_ev.VSOptimizedRoute.ListOfVisitedCustomerSiteIDs)
                    {
                        if (EVPremPayingCustomersList.Contains(csID))
                            numEVPremCustomersPerRoute++;
                        if (ISCustomersList.Contains(csID))
                            numISCustomersPerRoute++;
                    }
                    output.Add(i.ToString() + "\t" + alg + "\t" + instanceType + "\t" + instanceName + "\t" + instanceSize + "\t" +
                    numCustomers.ToString() + "\t" + numESs.ToString() + "\t" + evDrivingRange.ToString() + "\t" + ESrefuelingRate.ToString() + "\t" + ISrefuelingRate.ToString() + "\t" + avgSpeed.ToString() + "\t" +
                    evFixedCost.ToString() + "\t" + gdvFixedCost.ToString() + "\t" + evVariableCost.ToString() + "\t" + gdvVariableCost.ToString() + "\t" + basePrize.ToString() + "\t" +
                    numEVs.ToString() + "\t" + numISs.ToString() + "\t" + numPremiumPayingCust.ToString() + "\t" + premiumPercentIncrease.ToString() + "\t" +
                    
                    routeID.ToString() + "\t" + CS +"\t" + routeEV + "\t" + VehicleCategories.EV.ToString() + "\t" + numCustomersEVroute.ToString()+  "\t" + numISCustomersPerRoute.ToString() + "\t" + numEVPremCustomersPerRoute.ToString() + "\t" + numESVisitPerEVRoute.ToString() + "\t" + evVMT + "\t" +
                    prizeCollectedPerRoute.ToString() + "\t"+ variableCostPerRoute.ToString() + "\t" +evFixedCost.ToString()+"\t" +
                    
                    totalCustomersServed.ToString() + "\t"+ ActiveESs + "\t" + totalNumActiveESs.ToString() +  "\t" + evRouteCount.ToString() + "\t" + gdvRouteCount.ToString() + "\t" +
                    totalEVRoutesPrizes.ToString() + "\t" +totalGDVRoutesPrizes.ToString() + "\t" + totalEVVarCost.ToString() + "\t" + totalGDVVarCost.ToString() + "\t" + totalEVFixedCost+"\t"+totalGDVFixedCost.ToString() +"\t"+ totalProfit.ToString());
                }
                for (int r = 0; r < solution.Assigned2GDV.Count; r++)
                {
                    routeID++;
                    VehicleSpecificRouteOptimizationOutcome vsroo_gdv = solution.Assigned2GDV[r].RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV);
                    string routeGDV = String.Join("-", vsroo_gdv.VSOptimizedRoute.ListOfVisitedSiteIncludingDepotIDs);
                    string CS = String.Join("-", vsroo_gdv.VSOptimizedRoute.ListOfVisitedCustomerSiteIDs);
                    int numISCustomersPerRoute = 0;
                    int numEVPremCustomersPerRoute = 0;
                    foreach (string csID in vsroo_gdv.VSOptimizedRoute.ListOfVisitedCustomerSiteIDs)
                    {
                        if (EVPremPayingCustomersList.Contains(csID))
                            numEVPremCustomersPerRoute++;
                        if (ISCustomersList.Contains(csID))
                            numISCustomersPerRoute++;
                    }

                    int numCustomersGDVroute = vsroo_gdv.VSOptimizedRoute.NumberOfCustomersVisited;
                    int numESVisitPerGDVRoute = 0;
                    double gdvVMT = vsroo_gdv.VSOptimizedRoute.GetVehicleMilesTraveled();
                    double prizeCollectedPerRoute = vsroo_gdv.VSOptimizedRoute.GetPrizeCollected();
                    double variableCostPerRoute = gdvVMT * gdvVariableCost;

                    output.Add(i.ToString() + "\t" + alg + "\t" + instanceType + "\t" + instanceName + "\t" + instanceSize + "\t" +
                    numCustomers.ToString() + "\t" + numESs.ToString() + "\t" + evDrivingRange.ToString() + "\t" + ESrefuelingRate.ToString() + "\t" + ISrefuelingRate.ToString() + "\t" + avgSpeed.ToString() + "\t" +
                    evFixedCost.ToString() + "\t" + gdvFixedCost.ToString() + "\t" + evVariableCost.ToString() + "\t" + gdvVariableCost.ToString() + "\t" + basePrize.ToString() + "\t" +
                    numEVs.ToString() + "\t" + numISs.ToString() + "\t" + numPremiumPayingCust.ToString() + "\t" + premiumPercentIncrease.ToString() + "\t" +

                    routeID.ToString() + "\t" + CS + "\t" + routeGDV + "\t" + VehicleCategories.GDV.ToString() + "\t" + numCustomersGDVroute.ToString() + "\t" + numISCustomersPerRoute.ToString() + "\t" + numEVPremCustomersPerRoute.ToString() + "\t" + numESVisitPerGDVRoute.ToString() + "\t" + gdvVMT + "\t" +
                    prizeCollectedPerRoute.ToString() + "\t" + variableCostPerRoute.ToString() + "\t" + gdvFixedCost.ToString() + "\t" +

                    totalCustomersServed.ToString() + "\t" + ActiveESs + "\t" + totalNumActiveESs.ToString() + "\t" + evRouteCount.ToString() + "\t" + gdvRouteCount.ToString() + "\t" +
                    totalEVRoutesPrizes.ToString() + "\t" + totalGDVRoutesPrizes.ToString() + "\t" + totalEVVarCost.ToString() + "\t" + totalGDVVarCost.ToString() + "\t" + totalEVFixedCost + "\t" + totalGDVFixedCost.ToString() + "\t" + totalProfit.ToString());
                }
            }
            return output.ToArray();
        }
        string[] WriteSolutionStatistics()
        {
            List<string> output = new List<string>();
            output.Add("ID#\tNumCustomers\tStatus\tObjFncDifference\tAFVSolnTime\tGDVSolnTime\tNumESVisits\tGDVExploited\tAFVSolved\tAFVInfeasibileProved");
            int IDindex = 0;

            foreach (CustomerSet cs in exploredCustomerSetMasterList)
            {
                double objDiff = 9999999;
                double afvSolnTime = 0;
                double gdvSolnTime = 0;
                int numESVisits = 0;
                int numCustomers = cs.Customers.Count;
                bool gdvExploited = false;
                bool afvSolved = true;
                bool afvInfeasibleProved = false;

                if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV)
                {
                    objDiff = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).VSOptimizedRoute.GetVehicleMilesTraveled() - cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).VSOptimizedRoute.GetVehicleMilesTraveled();
                    numESVisits = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).VSOptimizedRoute.ListOfVisitedNonDepotSiteIDs.Count - cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).VSOptimizedRoute.NumberOfCustomersVisited;
                    afvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).ComputationTime;
                    gdvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).ComputationTime;
                    if (afvSolnTime == 0)
                    {
                        gdvExploited = true;
                        afvSolved = false;
                    }
                }
                else if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.InfeasibleForBothGDVandEV)
                {
                    if (cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV) != null)
                    {
                        gdvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).ComputationTime;
                    }
                    afvInfeasibleProved = true;
                    gdvExploited = true;
                    afvSolved = false;
                }
                else if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV)
                {
                    afvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).ComputationTime;
                    gdvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).ComputationTime;
                    if (afvSolnTime == 0)
                    {
                        gdvExploited = true;
                        afvSolved = false;
                        afvInfeasibleProved = true;
                    }
                }
                output.Add(IDindex.ToString() + "\t" + numCustomers.ToString() + "\t" + cs.RouteOptimizationOutcome.Status.ToString() + "\t" + objDiff.ToString() + "\t" + afvSolnTime.ToString() + "\t" + gdvSolnTime.ToString() + "\t" + numESVisits.ToString() + "\t" + gdvExploited.ToString() + "\t" + afvSolved.ToString() + "\t" + afvInfeasibleProved.ToString());
                IDindex++;
            }
            return output.ToArray();
        }
        void WriteStatsToFile(string filename, List<OptimizationStatistics> exploitingGDVoptStats)
        {
            StreamWriter sw = new StreamWriter(filename);
            sw.AutoFlush = true;
            sw.WriteLine(OptimizationStatistics.GetHeaderRow());
            foreach (OptimizationStatistics stat in exploitingGDVoptStats)
                sw.WriteLine(stat.GetDataRow());
            sw.Close();
        }
        void WriteIterationStatsToFile(string filename, List<CGIterationStats> cgIterationStatsList)
        {
            string instanceSize = "";
            string instanceType = "";
            if (theProblemModel.InputFileName.Contains("AB"))
                instanceType = "AB";
            else if (theProblemModel.InputFileName.Contains("20c3"))
                instanceType = "EMH";
            if (numCustomers <= 20)
                instanceSize = "XS";
            else if (numCustomers <= 50)
                instanceSize = "S";
            else if (numCustomers <= 75)
                instanceSize = "M";
            else if (numCustomers <= 100)
                instanceSize = "L";
            else if (numCustomers <= 200)
                instanceSize = "XL";
            else if (numCustomers <= 300)
                instanceSize = "XXL";
            else
                instanceSize = "XXXL";
            string alg = "";
            switch (flowchart)
            {
                case Exploiting_GDVs_Flowchart.a_NoExploiting:
                    alg = "No Exploiting";
                    break;
                case Exploiting_GDVs_Flowchart.b_OnlyIdenticalRoutes:
                    alg = "Only Identical Routes";
                    break;
                case Exploiting_GDVs_Flowchart.c_PathInsertedRoutes:
                    alg = "Path Inserted Routes";
                    break;
                case Exploiting_GDVs_Flowchart.d_PathInsertedAndSwappedRoutes:
                    alg = "Path Inserted And Swapped Routes";
                    break;
                case Exploiting_GDVs_Flowchart.e_DataCollection:
                    alg = "Data Collection";
                    break;
            }
            double UB = 999999999;
            if (allSolutions.Count() > 0)
                UB = allSolutions.Last().UpperBound;

            StreamWriter sw = new StreamWriter(filename);
            sw.AutoFlush = true;
            sw.WriteLine("Algorithm\tInstanceType\tInstanceName\tInstanceSize\t" + CGIterationStats.GetHeaderRow() + "\tIntegerObj\tBKS");
            foreach (CGIterationStats stat in cgIterationStatsList)
                sw.WriteLine(alg + "\t" + instanceType + "\t" + instanceName + "\t" + instanceSize + "\t" + stat.GetDataRow() + "\t" + UB.ToString() + "\t" + BKS.ToString());
            sw.Close();
        }

    }
}
