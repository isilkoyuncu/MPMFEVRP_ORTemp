using MPMFEVRP.Domains.AlgorithmDomain;
using MPMFEVRP.Domains.SolutionDomain;
using MPMFEVRP.Implementations.Algorithms.Interfaces_and_Bases;
using MPMFEVRP.Implementations.ProblemModels.Interfaces_and_Bases;
using MPMFEVRP.Implementations.Solutions;
using MPMFEVRP.Models;
using MPMFEVRP.Models.XCPlex;
using MPMFEVRP.SupplementaryInterfaces.Listeners;
using System;
using System.Collections.Generic;
using MPMFEVRP.Domains.ProblemDomain;
using System.Linq;
using MPMFEVRP.Utils;
using System.IO;


namespace MPMFEVRP.Implementations.Algorithms
{
    public class CGA_ExploitingGDVs : AlgorithmBase
    {
        //Algorithm parameters
        double epsilon = 0.01;
        int totalColumnsNeededPerIteration = 0;
        int columnsNeededPerCustomer = 1;
        bool preserveCustomerVisitSequence = false;
        bool swap2Recover = true;
        int randomSeed;
        private Random random;
        Selection_Criteria selectedCriterion;
        TSPSolverType tspSolverType;
        double runTimeLimitInSeconds = 0.0;
        int numCustomers;
        bool feasibleIsEnough;
        bool performSwap;

        XCPlexBase setPartitionSolver = null;
        XCPlex_SetCovering_wCustomerSets relaxedSetPartitionSolver;
        Dictionary<string, double> shadowPrices;
        XCPlexParameters XcplexParam;

        CustomerSetList columns2setCover;
        CustomerSetList exploredCustomerSetMasterList;

        CustomerSetBasedSolution solution = new CustomerSetBasedSolution();
        List<CustomerSetBasedSolution> allSolutions;
        CustomerSetBasedSolution incumbentSolution = new CustomerSetBasedSolution();
        List<double> incumbentTime;
        List<int> iterationNo;
        string[] writtenOutput;
        string[] writtenStatistics;
        double BKS;
        string instanceName = "";

        //Local statistics
        double totalRunTimeSec = 0.0;
        DateTime globalStartTime;
        DateTime globalFinishTime;
        DateTime localStartTime;
        DateTime localFinishTime;
        List<OptimizationStatistics> optStatistics;

        bool terminate;

        public CGA_ExploitingGDVs()
        {
            AddSpecializedParameters();
        }
        public override void AddSpecializedParameters()
        {
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_PRESERVE_CUST_SEQUENCE, "Preserve Customer Visit Sequence", new List<object>() { true, false }, true, UserInputObjectType.CheckBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_RANDOM_SEED, "Random Seed", "50"));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_NUM_COLUMNS_ADDED_PER_ITER, "Columns Added Per Iter", "50"));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_SELECTION_CRITERIA, "Random Site Selection Criterion", new List<object>() { Selection_Criteria.CompleteUniform, Selection_Criteria.UniformAmongTheBestPercentage, Selection_Criteria.WeightedNormalizedProbSelection, Selection_Criteria.UsingShadowPrices }, Selection_Criteria.UsingShadowPrices, UserInputObjectType.ComboBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_TSP_OPTIMIZATION_MODEL_TYPE, "TSP Type", new List<object>() { TSPSolverType.GDVExploiter, TSPSolverType.PlainAFVSolver, TSPSolverType.OldiesADF }, TSPSolverType.GDVExploiter, UserInputObjectType.ComboBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.PROB_BKS, "BKS", "0"));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_FEASIBLE_SUBSOLN_IS_ENOUGH, "Feasible Sub Soln is Good", new List<object>() { true, false }, false, UserInputObjectType.CheckBox));
            AlgorithmParameters.AddParameter(new InputOrOutputParameter(ParameterID.ALG_PERFORM_SWAP, "Adjacent Swap", new List<object>() { true, false }, true, UserInputObjectType.CheckBox));
        }
        public override void SpecializedInitialize(EVvsGDV_ProblemModel theProblemModel)
        {
            //Problem param
            this.theProblemModel = theProblemModel;
            numCustomers = theProblemModel.SRD.NumCustomers;

            //Algorithm param
            runTimeLimitInSeconds = AlgorithmParameters.GetParameter(ParameterID.ALG_RUNTIME_SECONDS).GetDoubleValue();
            preserveCustomerVisitSequence = AlgorithmParameters.GetParameter(ParameterID.ALG_PRESERVE_CUST_SEQUENCE).GetBoolValue();
            randomSeed = AlgorithmParameters.GetParameter(ParameterID.ALG_RANDOM_SEED).GetIntValue();
            random = new Random(randomSeed);
            totalColumnsNeededPerIteration = AlgorithmParameters.GetParameter(ParameterID.ALG_NUM_COLUMNS_ADDED_PER_ITER).GetIntValue();
            selectedCriterion = (Selection_Criteria)AlgorithmParameters.GetParameter(ParameterID.ALG_SELECTION_CRITERIA).Value;
            tspSolverType = (TSPSolverType)AlgorithmParameters.GetParameter(ParameterID.ALG_TSP_OPTIMIZATION_MODEL_TYPE).Value;
            feasibleIsEnough = AlgorithmParameters.GetParameter(ParameterID.ALG_FEASIBLE_SUBSOLN_IS_ENOUGH).GetBoolValue();
            performSwap = AlgorithmParameters.GetParameter(ParameterID.ALG_PERFORM_SWAP).GetBoolValue();

            BKS = Double.Parse(GetBKS()); // AlgorithmParameters.GetParameter(ParameterID.PROB_BKS).GetDoubleValue();
            XcplexParam = new XCPlexParameters();

            shadowPrices = new Dictionary<string, double>();
            columns2setCover = new CustomerSetList();
            exploredCustomerSetMasterList = new CustomerSetList();

            //Solution stat
            status = AlgorithmSolutionStatus.NotYetSolved;
            stats.UpperBound = double.MaxValue;
            allSolutions = new List<CustomerSetBasedSolution>();
            incumbentTime = new List<double>();
            iterationNo = new List<int>();
            optStatistics = new List<OptimizationStatistics>();
        }
        public override void SpecializedRun()
        {
            int count=0;//START ALGORITHM
            //int k=0;
            globalStartTime = DateTime.Now;
            SetInitialColumns(); //INITIALIZE COLUMN GENERATION BY GENERATING SINGLE CUSTOMER ROUTES
            localFinishTime = DateTime.Now;
            RunIntegerSetCoverAndUpdateSolutionList(count);          
            terminate = false;           
            while (!terminate) //KEEP ADDING COLUMNS WHILE TERMINATION CRITERIA IS NOT SATISFIED
            {
                if ((DateTime.Now - globalStartTime).TotalSeconds > runTimeLimitInSeconds) { terminate = true; break; }
                localStartTime = DateTime.Now;
                UpdateShadowPrices(exploredCustomerSetMasterList); //SOLVE THE RELAXED AND RESTRICTED MASTER PROBLEM; UPDATE SHADOW PRICES                
                //UpdateShadowPrices(columns2setCover);
                ExploreAndAddNewColumns(); //ADD PREDETERMINED NUMBER OF COLUMNS
                localFinishTime = DateTime.Now;
                count++;
                //k++;
                //if (k > 5) { RunIntegerSetCoverAndUpdateSolutionList(count); k = 0; } //CHECK IF IT IS TIME TO UPDATE THE INCUMBENT SOLUTION
                RunIntegerSetCoverAndUpdateSolutionList(count);
            }
            RunIntegerSetCoverAndUpdateSolutionList(count++);   //UPDATE THE INCUMBENT ONE LAST TIME
            globalFinishTime = DateTime.Now;
            totalRunTimeSec = (globalFinishTime - globalStartTime).TotalSeconds; //FINISH ALGORITHM
        }     
        public override void SpecializedConclude()
        {
            writtenOutput = WriteIncumbentSolutions();
            string fileName = theProblemModel.InputFileName;
            fileName = fileName.Replace(".txt", "output.txt");
            System.IO.File.WriteAllLines(@fileName, writtenOutput);

            writtenStatistics = WriteSolutionStatistics();
            string fileName2 = theProblemModel.InputFileName;
            fileName2 = fileName2.Replace(".txt", "statistics.txt");
            System.IO.File.WriteAllLines(fileName2, writtenStatistics);

            //Given that the instance is solved, we need to update status and statistics from it
            status = (AlgorithmSolutionStatus)((int)setPartitionSolver.SolutionStatus);
            stats.RunTimeMilliSeconds = (long)totalRunTimeSec;
            stats.LowerBound = setPartitionSolver.LowerBound_XCPlex;
            stats.UpperBound = setPartitionSolver.UpperBound_XCPlex;
            GetOutputSummary();
            //Create solution based on status: Not yet solved, infeasible, no feasible soln found, feasible, optimal
            switch (status)
            {
                case AlgorithmSolutionStatus.NotYetSolved:
                    {
                        //Actual Run Time:N/A, Complete Solution-LB:N/A, Best Solution-UB:N/A, Best Solution Found:N/A
                        bestSolutionFound = new CustomerSetBasedSolution();
                        break;
                    }
                case AlgorithmSolutionStatus.Infeasible://When it is profit maximization, we shouldn't observe this case
                    {
                        //Actual Run Time:Report, Complete Solution-LB:N/A, Best Solution-UB:N/A, Best Solution Found:N/A
                        bestSolutionFound = new CustomerSetBasedSolution();
                        break;
                    }
                case AlgorithmSolutionStatus.NoFeasibleSolutionFound:
                    {
                        //Actual Run Time=Limit:Report, Complete Solution-LB:N/A, Best Solution-UB:N/A, Best Solution Found:N/A
                        bestSolutionFound = new CustomerSetBasedSolution();
                        break;
                    }
                case AlgorithmSolutionStatus.Feasible:
                    {
                        //Actual Run Time=Limit:Report, Complete Solution-LB:Report, Best Solution-UB:Report, Best Solution Found:Report
                        bestSolutionFound = (CustomerSetBasedSolution)setPartitionSolver.GetCompleteSolution(typeof(CustomerSetBasedSolution));
                        break;
                    }
                case AlgorithmSolutionStatus.Optimal:
                    {
                        //Actual Run Time:Report<Limit, Complete Solution-LB = Best Solution-UB:Report, Best Solution Found:Report
                        bestSolutionFound = (CustomerSetBasedSolution)setPartitionSolver.GetCompleteSolution(typeof(CustomerSetBasedSolution));
                        break;
                    }
                default:
                    break;
            }
            bestSolutionFound.Status = status;
            bestSolutionFound.UpperBound = setPartitionSolver.UpperBound_XCPlex;
            bestSolutionFound.LowerBound = setPartitionSolver.LowerBound_XCPlex;
            WriteStatsToFile(StringOperations.AppendToFilename(theProblemModel.InputFileName, "_OptimizationStatistics"), optStatistics);
        }
        public override void SpecializedReset()
        {
            setPartitionSolver.ClearModel();
            setPartitionSolver.Dispose();
            setPartitionSolver.End();
            GC.Collect();
        }

        //THESE ARE UPDATED METHODS
        void SetInitialColumns()
        {
            for (int i = 0; i < theProblemModel.SRD.NumCustomers; i++)
            {
                CustomerSet singleCustomerCS = new CustomerSet(theProblemModel.GetAllCustomerIDs()[i], theProblemModel.GetAllCustomerIDs());
                columns2setCover.Add(OptimizeCS(singleCustomerCS));
            }
            exploredCustomerSetMasterList.AddRange(columns2setCover);
        }
        CustomerSet OptimizeCS(CustomerSet cs)
        {
            if (tspSolverType == TSPSolverType.GDVExploiter)
            {
                cs.OptimizeByExploitingGDVs(theProblemModel, preserveCustomerVisitSequence, feasibleIsEnough, performSwap);
                optStatistics.Add(theProblemModel.RetrieveExploitingGDVoptStat());
            }
            else if (tspSolverType == TSPSolverType.PlainAFVSolver)
            {
                cs.OptimizeByPlainAFVSolver(theProblemModel);
                optStatistics.Add(theProblemModel.RetrievePlainOptStat());
            }
            else
                cs.NewOptimize(theProblemModel);
            return cs;
        }
        List<CustomerSet> SwapAndInsertES2Recover(CustomerSet currentCS)
        {
            List<CustomerSet> potentialRecoveries = new List<CustomerSet>();
            //We know that currentCS.NumberOfCustomers >= 3
            for (int i=0; i<currentCS.NumberOfCustomers-1; i++)
            {                
                potentialRecoveries.AddRange(currentCS.SwapAndESInsert(i, theProblemModel));
            }
            return potentialRecoveries;
        }
        CustomerSetBasedSolution SetCover(CustomerSetList columnsToSetCover)
        {
            setPartitionSolver = new XCPlex_SetCovering_wCustomerSets(theProblemModel, XcplexParam, columnsToSetCover, noGDVUnlimitedEV: true);
            setPartitionSolver.Solve_and_PostProcess();

            CustomerSetBasedSolution outcome = (CustomerSetBasedSolution)setPartitionSolver.GetCompleteSolution(typeof(CustomerSetBasedSolution));
            if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.Feasible)
                outcome.Status = AlgorithmSolutionStatus.Feasible;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.Infeasible)
                outcome.Status = AlgorithmSolutionStatus.Infeasible;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.NoFeasibleSolutionFound)
                outcome.Status = AlgorithmSolutionStatus.NoFeasibleSolutionFound;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.NotYetSolved)
                outcome.Status = AlgorithmSolutionStatus.NotYetSolved;
            else if (setPartitionSolver.SolutionStatus == XCPlexSolutionStatus.Optimal)
                outcome.Status = AlgorithmSolutionStatus.Optimal;

            outcome.UpperBound = setPartitionSolver.UpperBound_XCPlex;
            outcome.LowerBound = setPartitionSolver.LowerBound_XCPlex;
            return outcome;
        }
        void UpdateShadowPrices(CustomerSetList columnsToSetCover)
        {
            relaxedSetPartitionSolver = new XCPlex_SetCovering_wCustomerSets(theProblemModel, new XCPlexParameters(relaxation: XCPlexRelaxation.LinearProgramming), columnsToSetCover, noGDVUnlimitedEV: true);
            relaxedSetPartitionSolver.Solve_and_PostProcess();
            shadowPrices = relaxedSetPartitionSolver.GetCustomerCoverageConstraintShadowPrices();
        }
        void ExploreAndAddNewColumns()
        {
            CustomerSetList newColumns = new CustomerSetList();
            
            List<string> sortedPotentialCustomerIDs = GetSortedPotentialCustomerIDs(); //SORT PROMISING CUSTOMERS IN DESCENDING SHADOW PRICES            
            foreach (string customerID in sortedPotentialCustomerIDs) //SELECT A PROMISING CUSTOMER
            {
                newColumns.AddRange(GetColumnsToBeAdded(customerID));
                if (newColumns.Count >= totalColumnsNeededPerIteration)
                    break;
            }
            columns2setCover.AddRange(newColumns);
        }
        List<string> GetSortedPotentialCustomerIDs()
        {
            var temp = (from entry in shadowPrices orderby entry.Value descending select entry);
            return temp.Where(x => x.Value >= 0).Select(x => x.Key).ToList();
        }
        CustomerSetList GetColumnsToBeAdded(string customerID) // columns to be added
        {
            double SPofCustomer = shadowPrices[customerID];
            CustomerSetList tempColumns = new CustomerSetList();
            List<double> tempReducedCosts = new List<double>();
            List<int> numCustomersInCS = new List<int>();
            List<double> keys = new List<double>();
            //SELECT A PROMISING COLUMN TO ADD THAT CUSTOMER
            foreach (CustomerSet cs in columns2setCover)
            {
                if (cs.Contains(customerID) || cs.ImpossibleOtherCustomers.Contains(customerID))
                    continue;
                else
                {
                    double estimatedReducedCost = cs.GetReducedCost() - cs.GetLongestArc() - GetShadowPricesInCS(cs) - SPofCustomer + cs.GetShortestTwoArcsToCSfromCustomerID(customerID, theProblemModel);
                    if (estimatedReducedCost < 0)
                    {
                        CustomerSet tempCS = new CustomerSet(cs);
                        tempCS.NewExtend(customerID);
                        tempColumns.Add(tempCS);
                        tempReducedCosts.Add(estimatedReducedCost);
                        numCustomersInCS.Add(tempCS.NumberOfCustomers);
                    }
                }
            }
            CustomerSet[] tempColsArray = tempColumns.ToArray();

            if (tempReducedCosts.Count >= 2 && numCustomersInCS.Count >= 2)
            {
                double max_X = tempReducedCosts.Max();
                double min_X = tempReducedCosts.Min();

                double max_Y = numCustomersInCS.Max();
                double min_Y = numCustomersInCS.Min();

                for (int i = 0; i < tempReducedCosts.Count; i++)
                {
                    double coeff1 = 1-(min_X - tempReducedCosts[i]) /(min_X- max_X) ;
                    double coeff2 = (numCustomersInCS[i] - min_Y) / Math.Max(1.0,max_Y - min_Y);

                    keys.Add(1.0 * coeff1 + 0.0 * coeff2);
                }
                double[] keysArray = keys.ToArray();
                numCustomersInCS = tempColsArray.Select(x => x.NumberOfCustomers).ToList();//.ToArray();//.OrderByDescending(c => c).ToArray();

                //Array.Sort(tempReducedCosts.ToArray(), tempColsArray);
                //Array.Sort(numCustomersInCS, tempColsArray);
                Array.Sort(keysArray, tempColsArray);
                Array.Reverse(tempColsArray);
            }
            CustomerSetList columnsToAdd = new CustomerSetList();
            int count = 0;
            //EXPLORE THE CUSTOMER + CUSTOMER SET PAIR USING THE SELECTED METHOD
            foreach (CustomerSet potentialColumn in tempColsArray)
            {
                OptimizeCS(potentialColumn);
                exploredCustomerSetMasterList.Add(potentialColumn);
                if (potentialColumn.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV)
                    if (potentialColumn.OFIDP.GetVMT(VehicleCategories.EV) - GetShadowPricesInCS(potentialColumn) < 0)
                    {
                        columnsToAdd.Add(potentialColumn);
                        count++;
                    }
                //if (swap2Recover && potentialColumn.RouteOptimizationOutcome.Status==RouteOptimizationStatus.OptimizedForBothGDVandEV)
                //{
                //    List<CustomerSet> potentialRecoveries = new List<CustomerSet>();
                //    if (potentialColumn.RouteOptimizationOutcome.TheListofVSROOs[1].Status == VehicleSpecificRouteOptimizationStatus.Optimized)
                //        if (potentialColumn.NumberOfCustomers >= 2)
                //            if (potentialColumn.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).VSOptimizedRoute.ListOfVisitedNonDepotSiteIDs.Count > potentialColumn.NumberOfCustomers)
                //            {
                //                potentialRecoveries = SwapAndInsertES2Recover(potentialColumn);
                //                exploredCustomerSetMasterList.AddRange(potentialRecoveries);
                //                //foreach (CustomerSet cs in potentialRecoveries)
                //                //{
                //                //    if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV)
                //                //        if (cs.OFIDP.GetVMT(VehicleCategories.EV) - GetShadowPricesInCS(cs) < 0)
                //                //            columnsToAdd.Add(cs);
                //                //}
                //            }
                //}
                if (count >= columnsNeededPerCustomer)
                    break;
            }
            return columnsToAdd;
        }
        double GetShadowPricesInCS(CustomerSet cs)
        {
            double outcome = 0;
            foreach (string id in cs.Customers)
                outcome += shadowPrices[id];
            return outcome;
        }
        void RunIntegerSetCoverAndUpdateSolutionList(int count)
        {
            solution = SetCover(exploredCustomerSetMasterList);
            //solution = SetCover(columns2setCover);
            if (solution.Status == AlgorithmSolutionStatus.Optimal)
            {
                if (count == 0 || incumbentSolution.UpperBound > solution.UpperBound)
                {
                    allSolutions.Add(solution);
                    iterationNo.Add(count);
                    incumbentTime.Add((localFinishTime - globalStartTime).TotalSeconds);
                    incumbentSolution = solution;
                    if (solution.UpperBound - BKS  <= epsilon)
                        terminate = true;
                }
            }
        }
        
        //DO NOT TOUCH THESE FOR NOW!!!
        string GetBKS()
        {
            double bestKnownSoln;
            if (theProblemModel.InputFileName.Contains("AB101"))
            {
                bestKnownSoln = 2566.62;
                instanceName = "AB101";
            }
            else if (theProblemModel.InputFileName.Contains("AB102"))
            {
                bestKnownSoln = 2876.26;
                instanceName = "AB102";
            }
            else if (theProblemModel.InputFileName.Contains("AB103"))
            {
                bestKnownSoln = 2804.07;
                instanceName = "AB103";
            }
            else if (theProblemModel.InputFileName.Contains("AB104"))
            {
                bestKnownSoln = 2634.17;
                instanceName = "AB104";
            }
            else if (theProblemModel.InputFileName.Contains("AB105"))
            {
                bestKnownSoln = 3939.96;
                instanceName = "AB105";
            }
            else if (theProblemModel.InputFileName.Contains("AB106"))
            {
                bestKnownSoln = 3915.15;
                instanceName = "AB106";
            }
            else if (theProblemModel.InputFileName.Contains("AB107"))
            {
                bestKnownSoln = 3732.97;
                instanceName = "AB107";
            }
            else if (theProblemModel.InputFileName.Contains("AB108"))
            {
                bestKnownSoln = 3672.4;
                instanceName = "AB108";
            }
            else if (theProblemModel.InputFileName.Contains("AB109"))
            {
                bestKnownSoln = 3722.17;
                instanceName = "AB109";
            }
            else if (theProblemModel.InputFileName.Contains("AB110"))
            {
                bestKnownSoln = 3612.95;
                instanceName = "AB110";
            }
            else if (theProblemModel.InputFileName.Contains("AB111"))
            {
                bestKnownSoln = 3996.96;
                instanceName = "AB111";
            }
            else if (theProblemModel.InputFileName.Contains("AB112"))
            {
                bestKnownSoln = 5487.87;
                instanceName = "AB112";
            }
            else if (theProblemModel.InputFileName.Contains("AB113"))
            {
                bestKnownSoln = 4804.62;
                instanceName = "AB113";
            }
            else if (theProblemModel.InputFileName.Contains("AB114"))
            {
                bestKnownSoln = 5324.17;
                instanceName = "AB114";
            }
            else if (theProblemModel.InputFileName.Contains("AB115"))
            {
                bestKnownSoln = 5035.35;
                instanceName = "AB115";
            }
            else if (theProblemModel.InputFileName.Contains("AB116"))
            {
                bestKnownSoln = 4511.64;
                instanceName = "AB116";
            }
            else if (theProblemModel.InputFileName.Contains("AB117"))
            {
                bestKnownSoln = 5370.28;
                instanceName = "AB117";
            }
            else if (theProblemModel.InputFileName.Contains("AB118"))
            {
                bestKnownSoln = 5756.88;
                instanceName = "AB118";
            }
            else if (theProblemModel.InputFileName.Contains("AB119"))
            {
                bestKnownSoln = 5599.96;
                instanceName = "AB119";
            }
            else if (theProblemModel.InputFileName.Contains("AB120"))
            {
                bestKnownSoln = 5679.81;
                instanceName = "AB120";
            }
            else if (theProblemModel.InputFileName.Contains("AB201"))
            {
                bestKnownSoln = 1836.25;
                instanceName = "AB201";
            }
            else if (theProblemModel.InputFileName.Contains("AB202"))
            { 
                bestKnownSoln = 1966.82;
                instanceName = "AB202";
            }
            else if (theProblemModel.InputFileName.Contains("AB203"))
            { 
                bestKnownSoln = 1921.59;
                instanceName = "AB203";
            }
            else if (theProblemModel.InputFileName.Contains("AB204"))
            { 
                bestKnownSoln = 2001.7;
                instanceName = "AB204";
            }
            else if (theProblemModel.InputFileName.Contains("AB205"))
            { 
                bestKnownSoln = 2793.01;
                instanceName = "AB205";
            }
            else if (theProblemModel.InputFileName.Contains("AB206"))
            { 
                bestKnownSoln = 2891.48;
                instanceName = "AB206";
            }
            else if (theProblemModel.InputFileName.Contains("AB207"))
            { 
                bestKnownSoln = 2717.34;
                instanceName = "AB207";
            }
            else if (theProblemModel.InputFileName.Contains("AB208"))
            { 
                bestKnownSoln = 2552.18;
                instanceName = "AB208";
            }
            else if (theProblemModel.InputFileName.Contains("AB209"))
            { 
                bestKnownSoln = 2517.69;
                instanceName = "AB209";
            }
            else if (theProblemModel.InputFileName.Contains("AB210"))
            { 
                bestKnownSoln = 2479.97;
                instanceName = "AB210";
            }
            else if (theProblemModel.InputFileName.Contains("AB211"))
            { 
                bestKnownSoln = 2977.73;
                instanceName = "AB211";
            }
            else if (theProblemModel.InputFileName.Contains("AB212"))
            { 
                bestKnownSoln = 3341.43;
                instanceName = "AB212";
            }
            else if (theProblemModel.InputFileName.Contains("AB213"))
            { 
                bestKnownSoln = 3133.24;
                instanceName = "AB213";
            }
            else if (theProblemModel.InputFileName.Contains("AB214"))
            { 
                bestKnownSoln = 3384.28;
                instanceName = "AB214";
            }
            else if (theProblemModel.InputFileName.Contains("AB215"))
            { 
                bestKnownSoln = 3480.52;
                instanceName = "AB215";
            }
            else if (theProblemModel.InputFileName.Contains("AB216"))
            { 
                bestKnownSoln = 3221.78;
                instanceName = "AB216";
            }
            else if (theProblemModel.InputFileName.Contains("AB217"))
            { 
                bestKnownSoln = 3714.94;
                instanceName = "AB217";
            }
            else if (theProblemModel.InputFileName.Contains("AB218"))
            { 
                bestKnownSoln = 3658.17;
                instanceName = "AB218";
            }
            else if (theProblemModel.InputFileName.Contains("AB219"))
            { 
                bestKnownSoln = 3790.71;
                instanceName = "AB219";
            }
            else if (theProblemModel.InputFileName.Contains("AB220"))
            { 
                bestKnownSoln = 3737.88;
                instanceName = "AB220";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU1_"))
            { 
                bestKnownSoln = 1797.49;
                instanceName = "EMH01";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU2"))
            { 
                bestKnownSoln = 1574.78;
                instanceName = "EMH02";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU3"))
            { 
                bestKnownSoln = 1704.48;
                instanceName = "EMH03";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU4"))
            { 
                bestKnownSoln = 1482.00;
                instanceName = "EMH04";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU5"))
            { 
                bestKnownSoln = 1689.37;
                instanceName = "EMH05";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU6"))
            { 
                bestKnownSoln = 1618.65;
                instanceName = "EMH06";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU7"))
            { 
                bestKnownSoln = 1713.66;
                instanceName = "EMH07";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU8"))
            { 
                bestKnownSoln = 1706.50;
                instanceName = "EMH08";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU9"))
            { 
                bestKnownSoln = 1708.82;
                instanceName = "EMH09";
            }
            else if (theProblemModel.InputFileName.Contains("20c3sU10"))
            { 
                bestKnownSoln = 1181.31;
                instanceName = "EMH10";
            }
            else
                throw new Exception("AB101-220 must be solved first.");
            return bestKnownSoln.ToString();
        }
        public override string GetName()
        {
            return "CGA with Exploiting GDVs";

        }
        public override string[] GetOutputSummary()
        {
            List<string> list = new List<string>{
                 //Algorithm Name has to be the first entry for output file name purposes
                "Algorithm Name: " + GetName(),
                //Run time limit has to be the second entry for output file name purposes
                "Parameter: " + algorithmParameters.GetParameter(ParameterID.ALG_RUNTIME_SECONDS).Description + "-" + algorithmParameters.GetParameter(ParameterID.ALG_RUNTIME_SECONDS).Value.ToString(),
                
                //Optional
                "Parameter: ",
                //algorithmParameters.GetAllParameters();
                //var asString = string.Join(";", algorithmParameters.GetAllParameters());
                //list.Add(asString);
                
                //Necessary statistics
                "CPU Run Time(sec): " + stats.RunTimeMilliSeconds.ToString(),
                "Solution Status: " + status.ToString()
            };
            switch (status)
            {
                case AlgorithmSolutionStatus.NotYetSolved:
                    {
                        break;
                    }
                case AlgorithmSolutionStatus.Infeasible://When it is profit maximization, we shouldn't observe this case
                    {
                        break;
                    }
                case AlgorithmSolutionStatus.NoFeasibleSolutionFound:
                    {
                        break;
                    }
                default:
                    {
                        list.Add("UB(Best Int): " + stats.UpperBound.ToString());
                        list.Add("LB(Relaxed): " + stats.LowerBound.ToString());
                        break;
                    }
            }
            string[] toReturn = new string[list.Count];
            toReturn = list.ToArray();
            return toReturn;
        }
        public override bool setListener(IListener listener)
        {
            throw new NotImplementedException();
        }
        string[] WriteIncumbentSolutions()
        {
            string instanceSize="";
            string instanceType="";
            if (theProblemModel.InputFileName.Contains("AB"))
                instanceType = "AB";
            else if(theProblemModel.InputFileName.Contains("20c3"))
                instanceType = "EMH";
            if (numCustomers <= 20)
                instanceSize = "XS";
            else if (numCustomers <= 50)
                instanceSize = "S";
            else if (numCustomers <= 75)
                instanceSize = "M";
            else if (numCustomers <= 100)
                instanceSize = "L";
            else if (numCustomers <= 200)
                instanceSize = "XL";
            else if (numCustomers <= 300)
                instanceSize = "XXL";
            else
                instanceSize = "XXXL";
            string alg = "";
            if (tspSolverType == TSPSolverType.GDVExploiter)
                alg = "Exploiting";
            else
                alg = "Plain";
            double initialGap = (allSolutions.First().UpperBound / BKS) - 1;
            double finalGap = (allSolutions.Last().UpperBound / BKS) - 1;
            if (finalGap < 0.00001)
                finalGap = 0.00001;
            List<string> output = new List<string>();
            output.Add("Algorithm\tInstanceType\tInstanceName\tNumCustomers\tInstanceSize\tIncumbentID#\tNumAFVUsed\tNumGDVUsed\tIterationNo\tObjValue\tBKS\tGap\tSolnTime");
            for (int i = 0; i < allSolutions.Count; i++)
            {
                CustomerSetBasedSolution solution = allSolutions[i];
                double gap = (solution.UpperBound / BKS) - 1;
                if (gap < 0.00001)
                    gap = 0.00001;
                double normalizedGap = (gap-finalGap) / (initialGap- finalGap);
                output.Add(alg +"\t"+instanceType + "\t" +instanceName +"\t" + numCustomers.ToString() + "\t"+ instanceSize + "\t" +  i.ToString() + "\t" + solution.NumCS_assigned2EV.ToString() + "\t" + solution.NumCS_assigned2GDV.ToString() + "\t" + iterationNo[i].ToString() + "\t" + solution.UpperBound.ToString() + "\t" +GetBKS().ToString() +"\t"+ gap.ToString() + "\t"+ incumbentTime[i].ToString());
            }
            return output.ToArray();
        }
        string[] WriteSolutionStatistics()
        {
            List<string> output = new List<string>();
            output.Add("ID#\tNumCustomers\tStatus\tObjFncDifference\tAFVSolnTime\tGDVSolnTime\tNumESVisits\tGDVExploited\tAFVSolved\tAFVInfeasibileProved");
            int IDindex = 0;

            foreach (CustomerSet cs in exploredCustomerSetMasterList)
            {
                double objDiff = 9999999;
                double afvSolnTime = 0;
                double gdvSolnTime = 0;
                int numESVisits = 0;
                int numCustomers = cs.Customers.Count;
                bool gdvExploited = false;
                bool afvSolved = true;
                bool afvInfeasibleProved = false;

                if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForBothGDVandEV)
                {
                    objDiff = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).VSOptimizedRoute.GetVehicleMilesTraveled() - cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).VSOptimizedRoute.GetVehicleMilesTraveled();
                    numESVisits = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).VSOptimizedRoute.ListOfVisitedNonDepotSiteIDs.Count - cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).VSOptimizedRoute.NumberOfCustomersVisited;
                    afvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).ComputationTime;
                    gdvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).ComputationTime;
                    if (afvSolnTime == 0)
                    {
                        gdvExploited = true;
                        afvSolved = false;
                    }
                }
                else if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.InfeasibleForBothGDVandEV)
                {
                    if (cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV) != null)
                    {
                        gdvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).ComputationTime;
                    }
                    afvInfeasibleProved = true;
                    gdvExploited = true;
                    afvSolved = false;
                }
                else if (cs.RouteOptimizationOutcome.Status == RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV)
                {
                    afvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV).ComputationTime;
                    gdvSolnTime = cs.RouteOptimizationOutcome.GetVehicleSpecificRouteOptimizationOutcome(VehicleCategories.GDV).ComputationTime;
                    if (afvSolnTime == 0)
                    {
                        gdvExploited = true;
                        afvSolved = false;
                        afvInfeasibleProved = true;
                    }
                }
                output.Add(IDindex.ToString() + "\t" + numCustomers.ToString() + "\t" + cs.RouteOptimizationOutcome.Status.ToString() + "\t" + objDiff.ToString() + "\t" + afvSolnTime.ToString() + "\t" + gdvSolnTime.ToString() + "\t" + numESVisits.ToString() + "\t" + gdvExploited.ToString() + "\t" + afvSolved.ToString() + "\t" + afvInfeasibleProved.ToString());
                IDindex++;
            }
            return output.ToArray();
        }
        void WriteStatsToFile(string filename, List<OptimizationStatistics> exploitingGDVoptStats)
        {
            StreamWriter sw = new StreamWriter(filename);
            sw.AutoFlush = true;
            sw.WriteLine(OptimizationStatistics.GetHeaderRow());
            foreach (OptimizationStatistics stat in exploitingGDVoptStats)
                sw.WriteLine(stat.GetDataRow());

            sw.Close();
        }

    }
}
