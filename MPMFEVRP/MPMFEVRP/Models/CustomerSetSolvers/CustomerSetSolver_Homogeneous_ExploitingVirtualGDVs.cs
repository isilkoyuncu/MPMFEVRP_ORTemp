using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MPMFEVRP.Domains.ProblemDomain;
using MPMFEVRP.Domains.SolutionDomain;
using MPMFEVRP.Models.CustomerSetSolvers.Interfaces_and_Bases;
using MPMFEVRP.Implementations.ProblemModels.Interfaces_and_Bases;
using MPMFEVRP.Domains.AlgorithmDomain;

namespace MPMFEVRP.Models.CustomerSetSolvers
{
    /// <summary>
    /// This class implements the flow chart in the second paper. AFV solver exploits the GDV optimal routes to speed up the process.
    /// </summary>
    public class CustomerSetSolver_Homogeneous_ExploitingVirtualGDVs : ICustomerSetSolver
    {
        CustomerSetSolverWithOnlyAFV AFV_Solver;
        CustomerSetSolverWithOnlyGDV GDV_Solver;
        public CustomerSetSolver_Homogeneous_ExploitingVirtualGDVs(EVvsGDV_ProblemModel theProblemModel)
        {
            AFV_Solver = new CustomerSetSolverWithOnlyAFV(theProblemModel);
            GDV_Solver = new CustomerSetSolverWithOnlyGDV(theProblemModel);
        }
        public RouteOptimizationOutcome Solve(CustomerSet customerSet, List<VehicleCategories> vehicleCategories, bool PreserveCustomerVisitSequence)
        {
            //first solve with gdv
            GDV_Solver.Solve(customerSet);
            //check solution if infeasible, 
            if (GDV_Solver.SolutionStatus == XCPlexSolutionStatus.Infeasible)
                return new RouteOptimizationOutcome(RouteOptimizationStatus.InfeasibleForBothGDVandEV);
            //return infeasible roo
            else if(GDV_Solver.SolutionStatus == XCPlexSolutionStatus.Optimal)
                //if feasible, 
                //check if gdv optimal route is afv feasible ->
                
                //yes
                //return roo as if optimized for both

                //no
                //check if 
            AFV_Solver.Solve(customerSet, PreserveCustomerVisitSequence);
            VehicleSpecificRouteOptimizationOutcome vsroo_AFV;
            //Return the desired outcome
            if (AFV_Solver.SolutionStatus == XCPlexSolutionStatus.Infeasible)
            {
                vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV, AFV_Solver.CPUtime, VehicleSpecificRouteOptimizationStatus.Infeasible);
            }
            else if (AFV_Solver.SolutionStatus == XCPlexSolutionStatus.Optimal)
            {
                //vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV, AFV_Solver.CPUtime, VehicleSpecificRouteOptimizationStatus.Optimized, vsOptimizedRoute: theProblemModel, theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.GDV));
            }
            else
                throw new System.Exception("The TSPsolverEV.SolutionStatus is neither infeasible nor optimal for vehicle category: ");

            return new RouteOptimizationOutcome();
                }
    }
}
