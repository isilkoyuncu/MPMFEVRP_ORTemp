using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MPMFEVRP.Domains.ProblemDomain;
using MPMFEVRP.Domains.SolutionDomain;
using MPMFEVRP.Models.CustomerSetSolvers.Interfaces_and_Bases;
using MPMFEVRP.Implementations.ProblemModels.Interfaces_and_Bases;
using MPMFEVRP.Domains.AlgorithmDomain;

namespace MPMFEVRP.Models.CustomerSetSolvers
{
    /// <summary>
    /// This class implements the flow chart in the second paper. AFV solver exploits the GDV optimal routes to speed up the process.
    /// </summary>
    public class CustomerSetSolver_Homogeneous_ExploitingVirtualGDVs : ICustomerSetSolver
    {
        readonly EVvsGDV_ProblemModel theProblemModel;
        readonly Vehicle theAFV;
        readonly Vehicle theGDV;
        readonly CustomerSetSolverWithOnlyAFV AFV_Solver;
        readonly CustomerSetSolverWithOnlyGDV GDV_Solver;
        //readonly CustomerSetSolverWithOnlyAFV AFV_SolutionChecker;
        public CustomerSetSolver_Homogeneous_ExploitingVirtualGDVs(EVvsGDV_ProblemModel theProblemModel)
        {
            this.theProblemModel = theProblemModel;
            theAFV = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.EV);
            theGDV = theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.GDV);

            AFV_Solver = new CustomerSetSolverWithOnlyAFV(theProblemModel);
            GDV_Solver = new CustomerSetSolverWithOnlyGDV(theProblemModel);
            //AFV_SolutionChecker = new CustomerSetSolverWithOnlyAFV(theProblemModel);
        }
        public RouteOptimizationOutcome Solve(CustomerSet customerSet, bool PreserveCustomerVisitSequence, bool feasibleAFVSolnIsEnough)
        {
            VehicleSpecificRouteOptimizationOutcome vsroo_GDV;
            VehicleSpecificRouteOptimizationOutcome vsroo_AFV;
            //first solve with gdv
            GDV_Solver.Solve(customerSet);
            //check solution if infeasible, 
            if (GDV_Solver.SolutionStatus == XCPlexSolutionStatus.Infeasible)
            {
                vsroo_GDV = new VehicleSpecificRouteOptimizationOutcome(theGDV.Category, GDV_Solver.CPUtime, VehicleSpecificRouteOptimizationStatus.Infeasible);
                vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(theAFV.Category, 0.0, VehicleSpecificRouteOptimizationStatus.Infeasible);
                return new RouteOptimizationOutcome(RouteOptimizationStatus.InfeasibleForBothGDVandEV, new List<VehicleSpecificRouteOptimizationOutcome>() { vsroo_GDV, vsroo_AFV });
            }
            //return infeasible roo
            else if (GDV_Solver.SolutionStatus == XCPlexSolutionStatus.Optimal)
            {
                //check afv-feasibility of the gdv-optimal route
                VehicleSpecificRoute vsr_GDV = GDV_Solver.GetVehicleSpecificRoutes(VehicleCategories.GDV).First();
                vsroo_GDV = new VehicleSpecificRouteOptimizationOutcome(theGDV.Category, GDV_Solver.CPUtime, VehicleSpecificRouteOptimizationStatus.Optimized, vsr_GDV);
                if (theProblemModel.CheckAFVFeasibilityOfGDVOptimalRoute(vsr_GDV))
                {
                    VehicleSpecificRoute vsr_AFV = new VehicleSpecificRoute(theProblemModel, theAFV, vsr_GDV.ListOfVisitedNonDepotSiteIDs);
                    vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(theAFV.Category, 0.0, VehicleSpecificRouteOptimizationStatus.Optimized, vsr_AFV);
                    return new RouteOptimizationOutcome(RouteOptimizationStatus.OptimizedForBothGDVandEV, new List<VehicleSpecificRouteOptimizationOutcome>() { vsroo_GDV, vsroo_AFV });
                }
                else //GDV-optimal route is not feasible for AFV
                {

                    if (theProblemModel.ProveAFVInfeasibilityOfCustomerSet(vsr_GDV) == AFVInfOfCustomerSet.AFVInfeasibilityOfCSProved)
                    {
                        vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(theAFV.Category, 0.0, VehicleSpecificRouteOptimizationStatus.Infeasible);
                        return new RouteOptimizationOutcome(RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV, new List<VehicleSpecificRouteOptimizationOutcome>() { vsroo_GDV, vsroo_AFV });
                    }
                    else // AFV-infeasibility of the customer set cannot be proved, yet :)
                    {
                        if (PreserveCustomerVisitSequence && feasibleAFVSolnIsEnough)
                        {
                            vsroo_AFV = GetVehicleSpecificRouteBySwapAndInsertES(vsr_GDV, theProblemModel);
                            if(vsroo_AFV.Status == VehicleSpecificRouteOptimizationStatus.Optimized)
                                return new RouteOptimizationOutcome(RouteOptimizationStatus.OptimizedForBothGDVandEV, new List<VehicleSpecificRouteOptimizationOutcome>() { vsroo_GDV, vsroo_AFV });
                            else
                                return new RouteOptimizationOutcome(RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV, new List<VehicleSpecificRouteOptimizationOutcome>() { vsroo_GDV, vsroo_AFV });
                        }
                        else
                        {
                            AFV_Solver.Solve(customerSet, PreserveCustomerVisitSequence, vsr_GDV);
                            if (AFV_Solver.SolutionStatus == XCPlexSolutionStatus.Optimal)
                            {
                                VehicleSpecificRoute vsr_AFV = AFV_Solver.GetVehicleSpecificRoutes(theAFV.Category).First();
                                //AFV_SolutionChecker.SolveWithSubOptSolution(customerSet, vsr_AFV);
                                //vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(theAFV.Category, AFV_Solver.CPUtime, VehicleSpecificRouteOptimizationStatus.Optimized, AFV_SolutionChecker.GetVehicleSpecificRoutes(theAFV.Category).First());
                                vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(theAFV.Category, AFV_Solver.CPUtime, VehicleSpecificRouteOptimizationStatus.Optimized, vsr_AFV);
                                return new RouteOptimizationOutcome(RouteOptimizationStatus.OptimizedForBothGDVandEV, new List<VehicleSpecificRouteOptimizationOutcome>() { vsroo_GDV, vsroo_AFV });
                            }
                            else
                            {
                                vsroo_AFV = new VehicleSpecificRouteOptimizationOutcome(theAFV.Category, AFV_Solver.CPUtime, VehicleSpecificRouteOptimizationStatus.Infeasible);
                                return new RouteOptimizationOutcome(RouteOptimizationStatus.OptimizedForGDVButInfeasibleForEV, new List<VehicleSpecificRouteOptimizationOutcome>() { vsroo_GDV, vsroo_AFV });
                            }
                        }
                    }
                }
            }
            else
                throw new System.Exception("The TSPsolverEV.SolutionStatus is neither infeasible nor optimal for vehicle category: ");
        }

        VehicleSpecificRouteOptimizationOutcome GetVehicleSpecificRouteBySwapAndInsertES(VehicleSpecificRoute vsr_GDV, EVvsGDV_ProblemModel theProblemModel)
        {
            List<VehicleSpecificRoute> vsr_AFV_list = new List<VehicleSpecificRoute>();
            List<string> sites = new List<string>();
            RefuelingPathList refuelingPaths = new RefuelingPathList();
            DateTime startTime = DateTime.Now;
            sites = vsr_GDV.ListOfVisitedSiteIncludingDepotIDs;
            List<string> tempSites = new List<string>(sites);

            string origin = "";
            string destination = "";
            string cs = "";
            for (int j = 1; j < sites.Count-1; j++)
            {               
                for (int i = 1; i < sites.Count; i++)
                {
                    tempSites = new List<string>(sites);
                    origin = sites[i - 1];
                    destination = sites[i];
                    foreach (RefuelingPath rp in theProblemModel.NonDominatedRefuelingPaths)
                    {
                        if (rp.Origin.ID == origin && rp.Destination.ID == destination && rp.GetRefuelingStopIDs().Count > 0)
                        {
                            tempSites.InsertRange(i, rp.GetRefuelingStopIDs());
                            tempSites.RemoveAt(0);
                            tempSites.RemoveAt(tempSites.Count - 1);
                            vsr_AFV_list.Add(new VehicleSpecificRoute(theProblemModel, theProblemModel.VRD.GetTheVehicleOfCategory(VehicleCategories.EV), tempSites));
                        }
                        tempSites = new List<string>(sites);
                    }
                }
                if (sites.Count <= 4)
                    break;
                cs = sites[j];
                sites.RemoveAt(j);
                sites.Insert(j + 1, cs);
            }
            double obj = Double.MaxValue;
            VehicleSpecificRoute vsr_AFV = new VehicleSpecificRoute(vsr_AFV_list.First());
            foreach(VehicleSpecificRoute route in vsr_AFV_list)
            {
                if (route.Feasible && route.GetVehicleMilesTraveled() < obj)
                {
                    vsr_AFV = new VehicleSpecificRoute(route);
                    obj = route.GetVehicleMilesTraveled();
                }
            }
            DateTime endTime = DateTime.Now;
            double swapInsertCPUtime = (endTime - startTime).TotalSeconds;
            if(vsr_AFV.Feasible)
                return new VehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV, swapInsertCPUtime, VehicleSpecificRouteOptimizationStatus.Optimized, vsOptimizedRoute: vsr_AFV);
            else
                return new VehicleSpecificRouteOptimizationOutcome(VehicleCategories.EV, swapInsertCPUtime, VehicleSpecificRouteOptimizationStatus.Infeasible);

        }





    }
}
